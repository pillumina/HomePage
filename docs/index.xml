<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CctoctoFX</title>
    <link>https://pillumina.github.io/</link>
    <description>Recent content on CctoctoFX</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Dec 2020 12:40:29 +0800</lastBuildDate><atom:link href="https://pillumina.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Black Magic</title>
      <link>https://pillumina.github.io/posts/black-magic/</link>
      <pubDate>Sun, 20 Dec 2020 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/black-magic/</guid>
      <description>阅读到的一些方便、有趣的技巧或者ideas的随手记录，后续考虑对相关话题专门开坑
一行代码画出专业的论文图 SciencePlots
计算机专业向来不缺少专业的绘图软件，从Excel到PPT，从最近沸沸扬扬的Matlab到Matplotlib、pyplot、ggplot，乃至其他更为专业的软件，着实丰富了我们的画图生活。
但是，这些软件或工具的背后，常常需要我们付出更多的努力：调色、统一格式、展示要高大上，等等。
现在，一款开源的软件工具包问世了：SciencePlots。它让你用一行代码画出天然高端且美观的论文图。
SciencePlots是一个依附于Matplotlib的扩展包，可以通过pip一键安装：
pip install SciencePlots 然后我们在画图时，只需要一句with.plt.style.context([&#39;science&#39;]):，就可以画出非常美观且专业的图：
你还可以加一个选项with.plt.style.context([&#39;science&#39;,&#39;ieee&#39;]):，就能画出IEEE格式的图：
甚至是超美的散点图：
还有很多自定义的图像风格，保证节约我们的画图时间
 这个包默认会调用latex来画图，如果不想用latex（也不是完全需要），可以在context里写一个属性&amp;rsquo;nolatex&amp;rsquo;即可。不然如果没有安装latex或latex路径配置有问题，则会报错。
 </description>
    </item>
    
    <item>
      <title>Tracking</title>
      <link>https://pillumina.github.io/posts/links/</link>
      <pubDate>Sat, 19 Dec 2020 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/links/</guid>
      <description>这个post为记录目前正在阅读与研究的section
Russ Cox正则表达式系列 You should not be permitted to write production code if you do not have an journeyman license in regular expressions or floating point math. &amp;ndash; Rob Pike
Regular Expression Matching Can Be Simple And Fast
编译器词法分析:正则语言和正则表达式
Heilmeier问题系列 思考某篇paper的选题
 What are you trying to do? Articulate your objectives using absolutely no jargon. How is it done today, and what are the limits of current practice? Who cares? [Support other’s research?</description>
    </item>
    
    <item>
      <title>Golang TDD</title>
      <link>https://pillumina.github.io/posts/golang/go-testing/</link>
      <pubDate>Sat, 19 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/go-testing/</guid>
      <description>Preface 本文整理golang编码的单元测试常用示例，以及TDD的简要流程。
单元测试基础 单元测试文件以_test.go结尾，需要记住以下原则：
 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。  Table-Driven-Testing 测试讲究 case 覆盖，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。
func TestFib(t *testing.T) { var fibTests = []struct { in int // input  expected int // expected result  }{ {1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 5}, {6, 8}, {7, 13}, } for _, tt := range fibTests { actual := Fib(tt.</description>
    </item>
    
    <item>
      <title>Golang并发调度</title>
      <link>https://pillumina.github.io/posts/golang/schedualing/</link>
      <pubDate>Thu, 17 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/schedualing/</guid>
      <description>性能提升不会凭空出现，它总是伴随着代码复杂度的上升。 The performance improvement does not materialize from the air, it comes with code complexity increase.
&amp;ndash; Dmitry Vyukov
Go 语言的调度器我认为应该是整个运行时最有趣的组件了。对于Go本身，它的设计和实现直接牵动了Go运行时的其他组件，也是和用户态代码直接打交道的部分；对于Go用户而言，调度器将其极为复杂的运行机制隐藏在了简单的关键字go下。为了保证高性能，调度器必须有效得利用计算的并行性和局部性原理；为了保证用户态的简洁，调度器必须高效得对调度用户态不可见的网络轮训器、垃圾回收器进行调度；为了保证代码执行的正确性，必须严格实现用户态代码的内存顺序等。总而言之，调度器的设计直接决定了Go运行时源码的表现形式。
设计原理 数据结构: MPG 调度器启动 创建Goroutine 调度循环 触发调度 线程管理 总结 </description>
    </item>
    
    <item>
      <title>Python类自定义</title>
      <link>https://pillumina.github.io/posts/python/python-functionality/</link>
      <pubDate>Mon, 14 Dec 2020 16:20:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/python/python-functionality/</guid>
      <description>python类关键字 __init__ vs __new__ __init__为初始化方法，__new__为真正的构造函数。
描述符Descriptor __contains__ __slots__ 定制类 type() python作为动态语言，和静态语言最大的不同，即函数和类的定义，不是编译的时候创建的而是动态创建的。我们常见的对类的定义:
class Hello(object): def hello(self, name=&amp;#39;world&amp;#39;): print(&amp;#39;Hello, %s.&amp;#39; % name) &amp;gt;&amp;gt;&amp;gt; from hello import Hello &amp;gt;&amp;gt;&amp;gt; h = Hello() &amp;gt;&amp;gt;&amp;gt; h.hello() Hello, world. &amp;gt;&amp;gt;&amp;gt; print(type(Hello)) &amp;lt;class &#39;type&#39;&amp;gt; &amp;gt;&amp;gt;&amp;gt; print(type(h)) &amp;lt;class &#39;hello.Hello&#39;&amp;gt; type()函数可以查看一类类型或者变量的类型，Hello是一个class， 它的类型是个type，而h是一个instance, 它的类型就是class Hello。
同时有一个概念，就是type()不仅可以返回对象的类型，还可以创建出新的类型。我们可以不用定义class Hello() ...而动态创建出Hello类。
&amp;gt;&amp;gt;&amp;gt; def fn(self, name=&#39;world&#39;): # 先定义函数 ... print(&#39;Hello, %s.&#39; % name) ... &amp;gt;&amp;gt;&amp;gt; Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn)) # 创建Hello class &amp;gt;&amp;gt;&amp;gt; h = Hello() &amp;gt;&amp;gt;&amp;gt; h.</description>
    </item>
    
    <item>
      <title>BDD: Ginkgo测试框架</title>
      <link>https://pillumina.github.io/posts/golang/bdd-testing-framework/</link>
      <pubDate>Fri, 04 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/bdd-testing-framework/</guid>
      <description>Preface BDD和TDD都是test case first的实现，无非是把后者的test改成前者的behavior。在TDD中，关注的核心点是function，即认为程序最基本单元是function，其test case可以认为是unit test，TDD和unit test的区别是TDD强调测试和开发结合而成的工作流: 写test case -&amp;gt; 写代码 -&amp;gt; 通过测试，继续写更多测试，写一次循环。
而BDD比TDD更关注高层的行为，而不是函数级别的行为，也就是在BDD中，不会强调函数的功能正确，这是unit test应该做的事。BDD更关注user story，即用户在特定场景，与软件交互发生的行为，这个behavior指的就是高层模块的行为。
如何区分BDD和TDD，简单理解，TDD是给programmer的，用来验证开发者的最基本模块的功能：在什么输入，应该产生什么输出，保证实现的边界，健全性。而BDD，其test case描述的是更高级的模块行为，脱离了具体的实现，容易用自然语言去描述，也就是BDD是给product manager的，告诉其系统的行为。
BDD in golang ​	实现的时候，我们需要把Given-When-Then这种story格式组织test case翻译为测试代码，通过一系列的assertion来检查实现是否符合test case的预期，我们完全可以直接通过golang自带的testing模块来实现，不过testing的功能有时候比较简陋，本文记录了用Ginkgo+Gomega来组织test case，让我们的测试语言更加接近自然语言。
二者结合的目的是，ginkgo实现了test case的组织，并加入了其他方便的功能: 初始化，后续处理，异步等等。而gomega设计的目的是与ginkgo一起工作，实现易读的assertion(ginkgo中称为match)功能。
Gomega is ginkgo&#39;s preferred matcher library 初始化 ginkgo依托golang原生testing框架，即可以用go test ./.. 执行，也可以通过ginkgo binrary安装go install github.com/onsi/ginkgo，封装了ginkgo测试框架的各种feature。
初始化首先进入待测试的package:
cd /path/to/package 执行初始化:
ginkgo bootstrap 生成以suite_test.go文件，接下来向suite添加测试specs，生成比如ginkgo_cart package测试文件。
ginkgo generate ginkgo_cart 运行 生成ginkgo_cart_test.go，注意测试文件在ginkgo_cart_testpackage， 需要import package ginkgo_cart，即BDD层级高于unit test, 不应该了解package内部的具体实现，测试package的外部接口即可。编写测试代码，运行go test ./..即可。
Ginkgo Keyword Ginkgo测试代码骨架由一系列keyword关联的闭包组成，常用的有：
 Describe/Context/When: 测试逻辑块 BeforeEach/AfterEach/JustBeforeEach/JustAfterEach: 初始化测试用例块 It: 单一Spec，测试case  keyword的声明均为传入Body参数，比如Describe:</description>
    </item>
    
    <item>
      <title>Golang内存管理</title>
      <link>https://pillumina.github.io/posts/golang/memory-management/</link>
      <pubDate>Wed, 02 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/memory-management/</guid>
      <description>设计原则 现在我们来看 Go 中另一重要的关键组件：内存分配器。
Go 的内存分配器基于 Thread-Cache Malloc (tcmalloc) ，tcmalloc 为每个线程实现了一个本地缓存， 区分了小对象（小于 32kb）和大对象分配两种分配类型，其管理的内存单元称为 span。
我们不再介绍更多 tcmalloc 的具体细节，因为 Go 的内存分配器与 tcmalloc 存在一定差异。 这个差异来源于 Go 语言被设计为没有显式的内存分配与释放， 完全依靠编译器与运行时的配合来自动处理，因此也就造就了内存分配器、垃圾回收器两大组件。
我们知道，在计算机领域中，无外乎时间换空间、空间换时间。统一管理内存会提前分配或一次性释放一大块内存， 进而减少与操作系统沟通造成的开销，进而提高程序的运行性能。 支持内存管理另一个优势就是能够更好的支持垃圾回收，这一点我们留到垃圾回收器的章节中进行讨论。
主要结构 Go 的内存分配器主要包含以下几个核心组件：
 heapArena: 保留整个虚拟地址空间 mheap：分配的堆，在页大小为 8KB 的粒度上进行管理 mspan：是 mheap 上管理的一连串的页 mcentral：收集了给定大小等级的所有 span mcache：为 per-P 的缓存。  其中页是向操作系统申请内存的最小单位，目前设计为 8KB。
每一个结构虽然不都像是调度器 M/P/G 结构那样的大部头，但初次阅读这些结构时想要理清他们之间的关系还是比较麻烦的。 传统意义上的栈被 Go 的运行时霸占，不开放给用户态代码；而传统意义上的堆内存，又被 Go 运行时划分为了两个部分， 一个是 Go 运行时自身所需的堆内存，即堆外内存；另一部分则用于 Go 用户态代码所使用的堆内存，也叫做 Go 堆。 Go 堆负责了用户态对象的存放以及 goroutine 的执行栈。
Arena heapArena Go 堆被视为由多个 arena 组成，每个 arena 在 64 位机器上为 64MB，且起始地址与 arena 的大小对齐， 所有的 arena 覆盖了整个 Go 堆的地址空间。</description>
    </item>
    
    <item>
      <title>Golang逃逸分析</title>
      <link>https://pillumina.github.io/posts/golang/golang-escape-analysis/</link>
      <pubDate>Mon, 23 Nov 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/golang-escape-analysis/</guid>
      <description>问题： golang函数传参是不是应该和c一样，尽量不要直接传结构体，而是要传结构体指针？
逃逸分析 逃逸分析指的是，在计算机语言编译器优化原理中，分析指针动态范围的方法，和编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中被分配后，其指针有可能被返回或者被全局引用，这种现象就是指针（或引用）的逃逸（Escape）。
其实在java概念中有一个误解 &amp;mdash; new出来的东西都在堆上，栈上存的是它的引用。 这句话在现代JVM上有问题，就是因为逃逸分析机制。简单来说，就是JVM的逃逸分析会在运行时(runtime)检测当前方法栈帧(frame)内new出来的对象的引用，是否被传出当前的栈帧。如果传出，就会发生逃逸，没有传出则不会。对于未发生逃逸的变量，则会直接在栈上分配内存。因为栈上内存由在函数返回时自动回收，而堆上的的内存需要gc去回收，如果程序中有大量逃逸的对象，那么势必会增加gc的压力。
public void test(){ List&amp;lt;Integer&amp;gt; a = new ArrayList&amp;lt;&amp;gt;(); a.add(1); // a 未逃逸，在栈上分配 } public List&amp;lt;Integer&amp;gt; test1(){ List&amp;lt;Integer&amp;gt; a = new ArrayList&amp;lt;&amp;gt;(); a.add(1); return a // 发生逃逸，因此分配在堆上 } 区别  不同于JVM运行时的逃逸分析，Golang的逃逸分析是在编译期完成。 golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。  go version go1.13.4 darwin/amd64 验证某个函数的变量是否发生逃逸的方法：
  go run -gcflags &amp;ldquo;-m -l&amp;rdquo; (-m打印逃逸分析信息，-l禁止内联编译)
  go tool compile -S xxxx.go | grep runtime.newobject（汇编代码中搜newobject指令，这个指令用于生成堆对象）
  备注： 关于-gcflags &amp;ldquo;-m -l&amp;quot;的输出，有两种情况：
 Moved to heap: xxx xxx escapes to heap  二者都表示发生了逃逸，当xxx变量为指针的时候，出现第二种；当xxx变量为值类型时，为上一种，测试代码：</description>
    </item>
    
    <item>
      <title>Design Pattern</title>
      <link>https://pillumina.github.io/posts/golang/design-pattern/</link>
      <pubDate>Wed, 11 Nov 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/design-pattern/</guid>
      <description>Design pattern Builder Pattern scenario：build complicated object package msg type Message struct { Header *Header Body *Body } type Header struct { SrcAddr string SrcPort uint64 DestAddr string DestPort uint64 Items map[string]string } type Body struct { Items []string } // Message对象的复杂对象 type builder struct{ once *sync.Once msg *Message } // 返回Builder对象 func Builder() *builder{ return &amp;amp;builder{ once: &amp;amp;sync.Once{}, msg: &amp;amp;Message{Header: &amp;amp;Header{}, Body: &amp;amp;Body{}}, } } func (b *builder) WithSrcAddr(srcAddr string) *builder{ b.</description>
    </item>
    
    <item>
      <title>MIT distributed system</title>
      <link>https://pillumina.github.io/notes/my-first-note/</link>
      <pubDate>Tue, 27 Oct 2020 10:40:12 +0800</pubDate>
      
      <guid>https://pillumina.github.io/notes/my-first-note/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java Fundamentals</title>
      <link>https://pillumina.github.io/posts/java/java-fundamentals/</link>
      <pubDate>Mon, 26 Oct 2020 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/java/java-fundamentals/</guid>
      <description>JAVA对象的equals方法和hashCode方法是这样规定的   相等（相同）的对象必须有相等的哈希码
  如果两个对象的哈希吗相同，它们不一定相同
  Java集合判断两个对象是否相等的规则：   判断两个对象的哈希码是否相等
  判断两个对象用equals是否相等
  所以重写其中一个方法，必须重写另一个方法
让对象可拷贝：
 实现java.lang.Cloneable 2. 重写Object的clone()方法  由于GC的自动回收机制，并不能保证finalize方法被及时的执行，因为对象的回收时机具有不确定性，或者要么没有触发垃圾回收。这个方法被禁止调用，应该用显式的close()方法。 Collection类的选择 Set:
排序吗？
是： TreeSet / LinkedHashSet
否： HashSet
List
要安全吗？
是： Vector
否： ArrayList或者LinkedList &amp;mdash; 查询多ArrayList，增删多LinkedList
Map常用子类：HashMap, HashTable, TreeMap, ConcurrentHashMap HashMap: 非线程安全，性能高，基于数组和链表实现。
TreeMap：有序键值对，按key排序
HashTable: 线程安全, 性能低
ConcurrentHashMap: 线程安全且性能较好。Java1.7采取分段锁，1.8采用CAS+synchronized保证并发安全。
LinkedHashMap 为HashMap的子类，内部还有一个双向链表维护键值对的顺序。支持插入顺序、访问顺序
  插入顺序：先添加在前，后添加在后
  访问顺序：即get/put操作，对一个键执行get/put操作后，对应的键值被移动到链表的末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的。
  有5种构造方法，4个是插入顺序，只有一个按照指定访问顺序，可以用于实现LRUCache
  集合初始化、大小和扩容 建议在集合初始化时指定集合容量大小 如果没有设置，元素增加，resize表会重建hash，影响性能</description>
    </item>
    
  </channel>
</rss>
