<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CctoctoFX</title>
    <link>https://pillumina.github.io/</link>
    <description>Recent content on CctoctoFX</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Apr 2021 11:22:18 +0800</lastBuildDate><atom:link href="https://pillumina.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker Fundamentals: AUFS</title>
      <link>https://pillumina.github.io/posts/cloud-computing/docker-aufs/</link>
      <pubDate>Tue, 06 Apr 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/cloud-computing/docker-aufs/</guid>
      <description>AUFS是一种Union File System，所谓的UnionFS实际上就是把不同物理位置的目录合并mount到同一个目录当中。一种典型的UnionFS的应用，就是把一张CD/DVD和一个硬盘目录联合mount在一起，然后你就可以对这个只读的CD/DVD上的文件进行修改。
AUFS又叫做Another UnionFS，后面改成Alternative UnionFS，然后又变成Advance UnionFS&amp;hellip;..当然名字的改变叫啥不重要，本质还是没变的。2006年Junjiro Okajima开发了AUFS，完全重写了早期的UnionFS 1.X，主要目的是为了可靠性和性能，再引入一些新的功能，例如可写分支的负载均衡。不过很有意思的是，AUFS的性能比UnionFS 1.X好很多，后面UnionFS 2.x就抄AUFS的功能，而AUFS本身却没有合入到Linux主线，因为代码量太大质量也不好。虽然后面Junjiro不断提升代码质量，不断提交但是还是被Linus拒绝了。所以哪怕是今天AUFS也没进到Linux里，虽然质量已经可以了。
不过一些发行版比如：Ubuntu 10.04，Debian6.0都支持AUFS，所以也还好。我在Ubuntu 14.04演示一下例子。
首先，我们建立两个水果和蔬菜的目录，在这个目录上放一些文件，水果里有苹果和番茄，蔬菜有胡萝卜和番茄:
$ tree . ├── fruits │ ├── apple │ └── tomato └── vegetables ├── carrots └── tomato 然后输入:
# 创建一个mount目录 $ mkdir mnt # 把水果目录和蔬菜目录union mount到 ./mnt目录中 $ sudo mount -t aufs -o dirs=./fruits:./vegetables none ./mnt # 查看./mnt目录 $ tree ./mnt ./mnt ├── apple ├── carrots └── tomato 可以看到mnt目录下有三个文件，水果和蔬菜的目录被合并起来了。如果我们修改一下文件内容:
$ echo mnt &amp;gt; ./mnt/apple $ cat .</description>
    </item>
    
    <item>
      <title>Docker Fundamentals: Cgroup</title>
      <link>https://pillumina.github.io/posts/cloud-computing/docker-cgroup/</link>
      <pubDate>Mon, 05 Apr 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/cloud-computing/docker-cgroup/</guid>
      <description>Linux Namespace的技术解决了环境隔离的问题，不过这是虚拟化最基本的一步，我们另外需要解决对计算机资源使用上的隔离。说人话，就是虽然Namespace把我关到一个特定的环境，但是里面进程使用的CPU、内存、磁盘等计算资源实际上没有被限制。这个问题的解决，就要用到CGroup技术。
Linux CGroup全称是Linux Control Group，也是其内核的一个功能，用于限制、控制和分离一个进程group的资源。最早这个项目是2006年由谷歌的工程师发起的，最开始名称是process containers（工程容器），后面觉得内核中容器这个名词被用烂了，就改名为cgroup。
CGroup可以让你对系统中运行的进程的用户组分配资源-CPU时间、系统内存、网络带宽亦或者是这些的组合。同时，也可以监控你配置的cgroup，拒绝cgroup访问某些资源。主要提供的功能如下：
  Resource Limitation： 限制资源使用
  Prioritization: 优先级控制，例如CPU使用和磁盘IO吞吐
  Accounting：审计统计，主要用于计费
  Control：挂起进程，恢复执行进程
在真正的实践当中，system admin一般会利用CGroup做以下的事：
  对进程集合进行隔离，限制他们所消费的资源，例如绑定CPU core
  为这组进程分配足够使用的内存
  为这组进程分配响应的网络带宽和磁盘存储限制
  限制访问某些设备（白名单）
Linux实际上把CGroup实现成了一个文件系统，你可以mount。在linux环境输入下面的可以看到cgroup已经为你mount好：
  derios@ubuntu:~$ mount -t cgroup cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset) cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu) cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct) cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory) cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio) cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio) cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb) 可以看到，在/sys/fs下有cgroup目录，这个目录下面有各种子目录：cpu，cpuset，memory&amp;hellip;。这些都是cgroup的子系统，分别用来干不同的事。</description>
    </item>
    
    <item>
      <title>Docker Fundamentals: Namespace</title>
      <link>https://pillumina.github.io/posts/cloud-computing/docker-namespace/</link>
      <pubDate>Thu, 01 Apr 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/cloud-computing/docker-namespace/</guid>
      <description>容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。
有时候我认为自己的阅读比较碎片化(short-term memory越来越少)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。
参考 Namespace in operation
Linux namespace man page
Introduction to linux namespace
什么是Namespace 简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。
这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。
Linux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：
   分类 系统调用参数 相关内核版本     Mount namespaces CLONE_NEWNS Linux 2.4.19   UTS namespaces CLONE_NEWUTS Linux 2.6.19   IPC namespaces CLONE_NEWIPC Linux 2.6.19   PID namespaces CLONE_NEWPID Linux 2.6.24   Network namespaces CLONE_NEWNET 始于Linux 2.6.24 完成于 Linux 2.</description>
    </item>
    
    <item>
      <title>Go编程模式：Visitor（k8s）</title>
      <link>https://pillumina.github.io/posts/design-pattern/go-visitor/</link>
      <pubDate>Wed, 31 Mar 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/design-pattern/go-visitor/</guid>
      <description>概述 最近在看kubernetes的kubectl部分源码，记录一下其中用到的visitor编程模式(实际上kubectl主要用到了builder和visitor)。visitor模式是将算法和操作对象结构分离的一种方法。换句话说，这样的分离能够在不修改对象结构的情况下向原有对象新增操作，是符合开闭原则的。这个文章以一些例子去讨论kubectl中到底如何玩的。
从一个例子出发 写一个简单的Visitor模式示例：
 我们的代码中有一个Visitor的函数定义，还有一个Shape接口，其需要使用 Visitor函数做为参数 我们的实例的对象 Circle和 Rectangle实现了 Shape 的接口的 accept() 方法，这个方法就是等外面给我传递一个Visitor。  package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;encoding/xml&amp;#34; &amp;#34;fmt&amp;#34; ) type Visitor func(shape Shape) type Shape interface { accept(Visitor) } type Circle struct { Radius int } func (c Circle) accept(v Visitor) { v(c) } type Rectangle struct { Width, Heigh int } func (r Rectangle) accept(v Visitor) { v(r) } 然后，我们实现两个Visitor，一个是用来做JSON序列化的，另一个是用来做XML序列化的:
func JsonVisitor(shape Shape) { bytes, err := json.</description>
    </item>
    
    <item>
      <title>Kubernetes Handbook (Start &amp; Pod)</title>
      <link>https://pillumina.github.io/posts/cloud-computing/k8s-basic/</link>
      <pubDate>Wed, 31 Mar 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/cloud-computing/k8s-basic/</guid>
      <description>使用minikube构建本地单节点k8s集群  minikube ssh kubectl cluster-info kubectl get nodes #查看节点信息 kubectl describe node minikube #详细信息  多节点k8s集群，使用Google K8s Engine 构建方式看GKE官网即可
k8s初步使用 kubectl run kubia &amp;ndash;image=derios/kubia &amp;ndash;port=8080 &amp;ndash;generator=run/v1
 --image=derios/kubia代表要运行的容器镜像 这里的--generator会被废弃，其含义指代的是创建一个ReplicationController而不是Deployment。 kubectl apply -f 更常用 kubectl get pods kubectl get pods -o wide 显示pod ip和pod的节点 如果使用GWE，可以访问集群的dashborad: kubectl clusert-info获取地址 gcloud container clusters describe kubia | grep -E &amp;ldquo;(username|password):&amp;ldquo;获取用户名和密码 如果仅仅使用minikube，则如下不需要任何凭证即可访问:  minikube dashboard 创建服务对象，访问Web应用 如果使用minikube或者kubeadm等自定义k8s，loadbalancer是没有集成的，需要AWS或者Google Cloud。最好使用NodePort或者Ingress Controller。如果真要用minikube, 可以使用minikube tunnel解决, 或者minikube service kubia-http
  kubectl expose rc/po/svc kubia &amp;ndash;type=LoadBalancer &amp;ndash;name kubia-http创建出的service介于pod和node之间, kubectl get services可以查看</description>
    </item>
    
    <item>
      <title>Docker Cheat Sheet</title>
      <link>https://pillumina.github.io/posts/cloud-computing/docker-basic/</link>
      <pubDate>Tue, 30 Mar 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/cloud-computing/docker-basic/</guid>
      <description>Books Docker in Action (English ver.)
Docker入门到实践(中文)
速查 Docker Cheat Sheet
全量CLI 容器管理CLI 查看容器CLI 容器交互CLI 镜像管理CLI 镜像传输CLI DOCKERFILE主要命令 Dockerfile 基底 FROMruby:2.2.2变量 ENV APP_HOME/myappRUN mkdir $APP_HOME初始化 RUN bundle installWORKDIR/myappVOLUME [&amp;#34;/data&amp;#34;]# Specification for mount pointADD file.xyz /file.xyzCOPY --chown=user:group host_file.xyz /path/container_file.xyzOnbuild ONBUILD RUN bundle install# when used with another file命令 EXPOSE5900CMD [&amp;#34;bundle&amp;#34;, &amp;#34;exec&amp;#34;, &amp;#34;rails&amp;#34;, &amp;#34;server&amp;#34;]Entrypoint ENTRYPOINT exec top -bMetadata LABEL version=&amp;#34;1.0&amp;#34;LABEL &amp;#34;com.example.vendor&amp;#34;=&amp;#34;ACME Incorporated&amp;#34;LABEL com.example.label-with-value=&amp;#34;foo&amp;#34;LABEL description=&amp;#34;This text illustrates \ that label-values can span multiple lines.</description>
    </item>
    
    <item>
      <title>Profiling a Go Service in Production</title>
      <link>https://pillumina.github.io/posts/golang/go-profiling/</link>
      <pubDate>Thu, 04 Mar 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/go-profiling/</guid>
      <description>Pro</description>
    </item>
    
    <item>
      <title>Life of an HTTP request in a Go server</title>
      <link>https://pillumina.github.io/posts/golang/lifecycle-of-http/</link>
      <pubDate>Sat, 20 Feb 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/lifecycle-of-http/</guid>
      <description>这篇文章的启发是我在阅读Go的http源码时获得的，之前对这块缺乏深入的了解，这篇文章会结合源码讨论包括典型http request的路由，还会涉及到一些并发和中间件的issue。
我们先从一个简单的go server谈起，下面的代码从https://gobyexample.com/http-servers 截取：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) func hello(w http.ResponseWriter, req *http.Request) { fmt.Fprintf(w, &amp;#34;hello\n&amp;#34;) } func headers(w http.ResponseWriter, req *http.Request) { for name, headers := range req.Header { for _, h := range headers { fmt.Fprintf(w, &amp;#34;%v: %v\n&amp;#34;, name, h) } } } func main() { http.HandleFunc(&amp;#34;/hello&amp;#34;, hello) http.HandleFunc(&amp;#34;/headers&amp;#34;, headers) http.ListenAndServe(&amp;#34;:8090&amp;#34;, nil) } 追踪请求的生命周期我们从http.ListenAndServe这个方法开始，下面的图示说明了这一层的调用关系:
这里实际上inlined了一些代码，因为初始的代码有很多其他的细节不好追踪。
主要的flow其实和我们预期的一致：ListenAndServe方法对你一个目标地址监听一个TCP端口，而后循环不断接受新的连接。每一个连接，它会起一个新的goroutine去serve，serve的具体操作是:
 从连接里解析HTTP请求： 产生http.Request 将http.Request传给用户自定义的handler  一个handler实际上就是实现了http.Handler接口：
type Handler interface { ServeHTTP(ResponseWriter, *Request) } 默认Handler 在我们上述的代码中，ListenAndServe方法的第二个参数为nil，实际上应该是用户自定义的handler, 这是为何？我们的图解中省去了很多细节，实际上当HTTP包serve一个请求的时候，它并没有直接调用用户的handlers而是使用一个adaptor：</description>
    </item>
    
    <item>
      <title>IaaS vs PaaS vs SaaS</title>
      <link>https://pillumina.github.io/posts/iaas-paas-diff/</link>
      <pubDate>Tue, 16 Feb 2021 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/iaas-paas-diff/</guid>
      <description>如果你在考虑将你的在线电子业务转移到云上，下面三个名词会经常遇到：
 IaaS PaaS SaaS  这些是云计算领域的三个主要类别
你很可能早就听说过它们，在各种各样的业务转移到云上的趋势下，它们各自占据的不同的比例：
 SaaS占据大概24%的企业负载 IaaS在12%左右波动 PaaS是近年来最流行的模型，大概占据32%，且当下和未来会有更多的增长  On-Premise, SaaS, PaaS, IaaS的关键区别 on-premise这里理解成本地部署的含义，比如企业内部部署的CRM软件系统，其反义词即为云端
不久以前，所有公司的IT系统都是on-premise的，云的概念比较模糊和遥远。
SaaS, PaaS, IaaS只是三种简单描述你如何为你的业务使用云设施的方式：
 IaaS: cloud-based services, 为存储、网络以及虚拟化等服务提供pay-as-you-go PaaS: 通过internet提供硬件和软件工具 SaaS: 完全由第三方提供的软件服务 On-Premise: 企业内部部署  下面是一个图解：
SaaS, PaaS, IaaS 举例 大多数的业务一般使用SaaS以及IaaS云计算服务模型的组合，此外有很多业务会鼓励开发者使用PaaS去构建应用。
SaaS举例： BigCommerce, Google Apps, Salesforce, Dropbox, MailChimp, ZenDesk, DocuSign, Slack, Hubspot.
PaaS举例： AWS Elastic Beanstalk, Heroku, Windows Azure (mostly used as PaaS), Force.com, OpenShift, Apache Stratos, Magento Commerce Cloud.
IaaS举例： AWS EC2, Rackspace, Google Compute Engine (GCE), Digital Ocean, Magento 1 Enterprise Edition*.</description>
    </item>
    
    <item>
      <title>Go编程模式：Pipeline</title>
      <link>https://pillumina.github.io/posts/design-pattern/go-pipeline/</link>
      <pubDate>Wed, 03 Feb 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/design-pattern/go-pipeline/</guid>
      <description>概述 这篇文章介绍Go编程里的Pipeline模式。如果是对Unix/Linux命令行熟悉的人会知道，Pipeline其实就是把每个命令拼接起来完成一个组合功能的技术。当下诸如流式处理，函数式编程，以及应用Gateway对微服务进行简单API编排，其实都受pipeline技术方式的影响。换句话说，这种技术能够很容易得把代码按照单一职责的原则拆分成多个高内聚低耦合的小模块，然后拼装起来去完成比较复杂的功能。
​</description>
    </item>
    
    <item>
      <title>别让自己墙了自己</title>
      <link>https://pillumina.github.io/posts/do-not-wall/</link>
      <pubDate>Mon, 01 Feb 2021 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/do-not-wall/</guid>
      <description>这篇文章摘自陈皓（左耳朵耗子）的blog（2019/12/01上传），作为给自己的提醒。
这一两周与几个朋友聊天，有年轻的90后，也有大叔级的70后，这些人在我看来都是很有能力的人，但是一些喜好过于强烈，让我不经意地回顾了我工作20年来身边的人，有发展得好的，也有发展的不好的，有些人是很可惜的，因为限制他们的不是其它人，也不是环境，而是自己，所以，很想写下这篇文章。（注：这篇文章可能会是一篇说教的文章，所以，可能会让你看着犯困，所以，我会尽量地短一些，而且尽可能多讲故事，少道理，这里的故事，全是真实发生的）
几个故事 2019年年初，我面试了一个很年轻的小伙子（93/94年出生），这个小伙子特别有灵性，也很聪明，计算机专业出身，也很喜欢技术，基础和学习能力也很好。在我这20年来认识的人中，如果他能呆在北京、上海、深圳这样的城市，我保证不出三年，他会成为他们同龄人中非常出色的技术人员，如果有个好的舞台有一个好的团队带他，他的未来会非常成功。然而，这个小伙子有两大喜好：1）只愿（或是说被迫）呆在一个毫无IT的环境的三/四线城市，2）对技术有非常大的偏好，只喜欢Go语言，非常不喜欢其它的语言，比如：Java（离开Java的世界，基本上离开了做架构的世界（相关解释见文末））。
他的这两个喜好，足以让一个未来会很优秀的人毁掉，因为，这个时代没有限制他，他的能力也没有限制他，但是他的意识完完全全地限制了他。
 他把自己最宝贵的青春放在了很烂的项目上，就算能用一些新的技术，他也只能算是自娱自乐，在实验室中玩玩具罢了。 他把自己的技术栈封闭起来，而直接放弃了这个时代最具工业化的技术Java，对于一个好的程序员来说，同时掌握几门语言和技术完全是没什么问题，但是自己封闭了自己的视野。  实在是非常可惜，我本来是可以为他介绍到一些很不错的公司的，但是他这样的习性，等于自己把自己未来的门给关上了，虽然我跟他长谈过，但是我也没有办法叫醒不想醒的人……
 视野、环境和舞台，对一个人的限制是非常大的。井蛙不知道大海，被空间维度所限制；夏虫不知道冬天，是被时间维度所限制；圈养的动物没有斗志，是被自己意识所限制。 偏见和不开放，对一个人的限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己的能力阉割掉，这是一件令人痛心的事。想想大清的闭关锁国是如何让亚洲第一的北洋水师给毁掉的……  我还有个同学，他的技术并不差，就算呆在昆明这种很落后的地方，他也非常地好学，学习英文，学习各种新技术，对技术没有任何的偏好，喜欢C/C++/Java/Python/Shell，同样喜欢前端Javascript，对基础知识非常地踏实，他在技术上没有限制自己的潜力，有什么就学什么。后来，我带他玩Docker/Go/K8S……分布式架构，他也上手的很快……像他这样的人，技术能力完全没得说，比我还大一岁，44岁了，还是一样的天天追代码细节，看Youtube的各种大会，翻github里的各种issue和pull request……
我同学这人，拥有了成为一个技术牛人几乎所有的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点……然而，只有一个小问题，就是没有到大公司历练过，我三番五次叫他从昆明出来，但是最终他都呆在昆明这个城市没有出来，因为有所谓的家庭约束。然而，我身边还有好些人，把自己家从北京搬到上海，从上海搬到深圳，从厦门搬到深圳……这样的人大有人在……像他这样的能力，在哪个公司都会是主力和骨干，对于一个公司的主力和骨干来说，家庭上的这些问题都是小问题都是有很多解的……
另外，我这个同学还是一个比较悲观的人，任何事情都是先想到不好的事，他关注负面的东西会胜于正面的东西，而且他还有一定的社交恐惧，怕与人相处和交流，时间越长越害怕，甚至有时候直接跟我说，“我就是不想改变”这样的话……其实，我以前也是一个很害怕与人交流的人，面试的时候，我根本不敢正眼看面试官一眼，也不知道与人怎么交流。但是，我与他不一样，我努力克服，不断地面试，与人面对面的交流，到一线技术客服接用户的电话，在公司里做分享，慢慢地到外面分享……3-5年就完全克服掉了。
其实，很多事情，完全是有解的，也没有必要担心，自己的心理障碍也是可以克服的，重点就是自己愿不愿意，只要愿意完成了一半，接下来就是不断的摸爬滚打坚持了。
 不限制自己的人，会穷举各种方法来解决问题，限制自己的人，只会找各式各样的问题或借口。 不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人，会放任自己。  另外几个故事 我还有另外几个故事（活到四十多，能看到好多人十几年的发展过程，感觉有点上帝视角了）
我还有一个以前团队里的一个小伙，人是很聪明，但就完全就是野路子，他对技术没有什么偏好，一个PHP程序员，做那个Discuz!论坛，公司被并购了，转成Java，开始研究Java的各种细节，对技术从来没有什么偏见，有什么就玩什么，每做一个项目，就算是一样的他都要用新的技术做一遍，然后跟着我做云计算，我教他TCP，教他C/C++，后来一起玩Docker/Go，等等，反正是一点就通，他是我见过学习能力最强的人。但是，有一个事他一直与我的想法不一样，就是我希望他先把软件设计好，再写代码，他非常不能理解，他习惯于直接动手开干，然后有什么问题就整什么问题，我也很难教育他。
有一天，他电话面了一下Facebook，电话面了15分钟后对方就放弃了，他受到了严重的打击。然后，他就开始找菲利宾人练英文口语了，我也让他做算法题，然后，他才发现，一道连算法都不是的纯编程题都提交几次都过不了，等他做完了Leetcode最初的那151道题后，整个人都改变了，写代码前认认真真地在纸上把程序的状态，处理时序以及可能遇到的一些条件先罗列出来，然后，进行逻辑设计后，再写，从此，他就开启他更大的天地了。我后来把他推荐给了微软，先在中国的Bing，在中国升好2-3级，然后去了美国的Azure，现在听说他准备要跟 k8s 的 co-founder Brendan Burns 混了（虽然，他现在还在印度人手下，但是，我真的不知道他未来能玩多大，因为今年他才33岁，而且非常聪明）
 他以前是把自己封闭起来的，我叫他出来，他也不出来，后来因为一些办公室政治的原因不得不来找我，于是我就带着他玩了两年，跟他讲了很多外面的世界是怎么玩的，他这个人也是一个相当不善于社交的人，但是心是开放的，愿意接受新的东西，虽然对技术也有一定偏见，比如不喜欢Windows，但是也不会不喜欢到完全封闭。后来我跟他说，微软的技术相当的强的，你看到的技术只是表面，深层次的东西都是相通的，直到他到了微软后发现各种牛逼的东西，对微软系统的技术的态度也有了改变，而且我让他跟我说很多微软那边的事，我发现，他对技术了解的维度已经是越来越高级的了……  还是我以前团队的一个小伙，他是一个前端，他说前端的东西没什么意思，想来找我做后端，我也一点点带他……后来，我说，你如果想要玩得好，你必需来北京，无论现在你觉得过得有多好，你都要放弃掉，然后，尽最大可能出去经历一下世界最顶尖的公司，我甚至跟他说，如果他女朋友不跟来的话，就先分开一段时间，先自己立业，他来北京的时候，他之前的同事都等着看他的笑话，我说，那些人连想都不敢想，不必管他们。于是，他去了Amazon，再过了一年去了西雅图，我跟他说，接下来就是去AWS，然后，如果有足够的野心，用自己的年轻这个资本去硅谷创业公司赌一把……未来他怎么样我不知道，但至少他没有限制自己，他的未来不会有封顶……
也是我的同学，我跟他在大学是上下铺，后来他去了人民大学读计算机博士，大学的时候做国产数据库kingbase，然后去了一家外企，天天被派到用户那边做数据分析，后来，他想回科研单位做国产数据库，我说，别啊，你的技术比我好太多，还有博士理论加持，你不去国外顶尖公司玩玩，你不知道自己有多强的，于是他跟公司申请去了国外做核心，后来因为Hadoop的原因，公司的产品最终成为了历史，于是我说，你来了美国么，你一定要去AWS，于是他就去了AWS的Aurora团队，成为了AWS明星级产品的中坚力量，天天在改MySQL的核心源码，干了两年，正在晋升 Principal Software Engineer ……
这里我到不是说出国有多牛，也许你只关注能挣多少钱，但是我想说，他们之所以能有这样的际遇，除了他们本来就有实力，还更因为他们从来不给自己设制什么限制，就是那种“艺多不压身”，有什么就学什么，有更高的就去向更高的迈进，其它的像家庭什么的问题其实都是会有解的，真的不必担心太多……
别限制了自己 上面的这些故事，也许你能看得懂，也许你看得不一定能懂，这里，让我来做个总结吧
 做有价值的事。这个世界对计算机人才的要求是供不应求的，所以，不要让自己为自己找各式各样的借口，让自己活在“玩玩具”、“搬砖”和“使蛮力加班”的境地。其实，我发现这世界上有能力的人并不少，但是有品味的人的确很少。所谓的有价值，就是，别人愿付高价的，高技术门槛的，有创造力的，有颠覆性的…… 扩大自己的眼界，开放自己的内心。人要变得开放，千万不要做一个狭隘的民族主义者，做一个开放的人，把目光放在全人类这个维度，不断地把自己融入到世界上，而不是把自己封闭起来，这里，你的英文语言能力对你能不能融入世界是起决定性的作用。开放自己的心态，正视自己的缺点，你才可能往前迈进。你的视野决定了你的知不知道要去哪，你的开放决定了你想不想去。 站在更高的维度。面的维度会超过点的维点，空间的维度会超过面的维度，在更高维度上思考和学习，你会获得更多。整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……），只会让你变得越来越平庸，只要你站在更高的维度（比如： 眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……），时间会让你明白那些低维度的东西全都不是事儿。技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。 精于计算得失。很多人其实不是很懂计算。绝大多数人都是在算计自己会失去多少，而不会算会得到多少。而一般的人也总是在算短期内会失去什么，优秀则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。*精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。* 勇于跳出传统的束缚。有时候，跳出传统并不是一件很容易的事，因为大多数人都会对未知有恐惧的心理。比如：我看到很多人才都被大公司垄断了，其实，有能力的人都不需要加入大公司，有能力的人是少数，这些少数的人应该是所有的公司share着用的，这样一来，对于所有的人都是利益最大化的。这样的事现在也有，比如：律师、设计师……。但是，绝大多数有能力的技术人员是不敢走出这步。我在2015年到2016年实践过一年半，有过这些实践，做“鸡”的比“二奶”好多了，收入也好很多很多（不好意思开车了）……  庄子说过几句话——
 井蛙不可以语于海者，拘于虚也；//空间局限
夏虫不可以语于冰者，笃于时也；//时间局限
曲士不可以语于道者，束于教也。//认识局限
 别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想，共勉！
————————————————————
注：这篇文章就是要劝大家更为开放，让自己有更多的可能性，能到更高的层次，做更有价值的事，成为更强更好的人……当然，如果你觉得你只想做一个平凡人，也和本文并不冲突……另外你也不要觉得这篇文章是让你要成为一个精英，但你一定要去摸高……这篇文章是告诉你一种面对人生的思考方式，在这种思考方式下，你会有更多的可能性，更大的场景……而不是直接把自己归到“平常人”，把自己“墙”了！
注：我以为用Java适合做架构这事应该是常识了，但是评论中有很多人非常反对这个事。那我解释一下吧：首先，小型的项目用什么语言都行，爱用什么用什么。但是，真正的企业级架构就不一样了，其中并不仅仅只是RESTful API或RPC，还有各种配套设施和控制系统，比如：应用网关，服务发现、配置中心、健康检查、服务监控、服务治理（熔断、限流、幂等、重试、隔离、事务补偿）、Tracing监控、SOA/ESB、CQRS、EDA……这些东西在非Java的技术栈体系内，很难看到全貌，Java强大的生态环境，就是让你把注意力放到更高层次的架构和业务上来的。（千万不要觉得，整几个服务RPC一下，加个缓存，加个队列，就能叫架构，那只是系统集成罢了）</description>
    </item>
    
    <item>
      <title>工程师应该如何高效学习</title>
      <link>https://pillumina.github.io/posts/how-to-learn/</link>
      <pubDate>Mon, 01 Feb 2021 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/how-to-learn/</guid>
      <description>此文转自曹春晖blog，也用于自己学习的一些参考
博客地址
阅读书籍 对于工程师来说，从书籍得来的知识是必不可少的。现在很多年轻的程序员会从网络博客来学习技术，但博客内容大多缺乏体系(主要说总结性质的博客内容)，不系统。很多博主为了掩饰自己的未知，遇到不知道的关键点就一笔带过，进而导致缺失。即使原作者非常努力，内容上没有缺失，你能从中获取的也只是别人总结好的知识，没有自己的主动思考，这中间便缺少过程式的沉淀，一味地满足于背诵别人总结好的知识，最后也只不过沦为他人的复读机而已。
对于工程师来说，书籍依然是最重要的知识获取媒介。即使只是通过目录概览，也能获取某个领域的大致蓝图。
目前大部分优秀的技术书籍依然以英文为主，能够读懂英文技术书籍是工程师的硬实力。英语阅读能力怎么训练呢？如果不是为了应试，可以尝试逼迫自己去翻译一些英文文档/文章来进行专门训练。举个例子，为了学习 Go，笔者曾经和社区的小伙伴合作翻译过《The Go Programming Language》，后来为了深入学习 es，参与了社区的 《es 权威指南》 的翻译和校对工作。如果某篇技术文档你从生理上很厌恶它，但是又觉得内容不得不学习的话，那你就逼迫自己去翻译它。千字以内的文档，周末抽一个下午就可以搞定。这里已经说是逼迫了，自然可以想见这个过程并不像打游戏那么轻松愉快，但只要熬过了这个阶段，阅读技术相关的英文文档可以显著提升速度。
具备一定的英语能力之后，接下来就是从什么渠道去获取内容。如果对电子书不排斥的话，目前比较经济的选择是申请一个国内的 ACM 会员，并且用该会员去注册oreily 在线书店。一年大概 20 美元，可以及时地阅读到大部分出版社的技术出版物。因为现在出版社的网站大多还支持 early preview，所以你甚至可以在书籍还没有上市之前就预先学习内容，第一时间获取整个业界的一线情报，能够帮助你站在时代的潮头。等两年后同事拿到翻译生涩的中文版的时候，你已经可以从容地 diss 他在信息源上落后了自己整整两年。(当然，如果你有兴趣，国内的出版社一般在英文新书出版的时候会招募翻译志愿者，如果你对一个领域特别感兴趣，关注出版社的这些招募消息也可以去参与。这里要指出，不要对做翻译这件事情抱太高期望，重在提升自己的能力。想赚钱的话就算了。)
如果喜欢一边阅读一边在页边写写画画，电子书还是稍微困难点，当然这个问题你也可以用 ipad pro + apple pencil 来解决。但有些人比较喜欢实体书捧在手上的实感，国外有些书甚至是个人出版物，例如笔者之前购入的《timeless law of software development》，这些书在互联网上正盗均无，只能考虑通过海淘渠道入手。前些年淘宝的海淘服务也可以用来淘书，书籍大多比较重，运费不菲。有些老书运费可能会到书费的一半让人格外肉疼。又因为国内对出版物管制比较严格，所以为了避险，这两年这些海淘服务商基本上都不帮忙代购出版物了。对于个人用户来说，也就只剩下了直邮和转运两种选择。直邮虽然比较便宜，但是万国联盟的 EMS 一走到中国可能就上了牛车，速度慢到突破极限。基本脑子稍微正常的都会选择转运。除了速度之外，有些出版社的书籍是只在美帝本土销售的，不支持 global delivery。
走转运的话，需要办一张 visa 或者 mastercard 的多币种信用卡，这样才能在海外网站进行支付 。
上面这些问题都解决了以后，书籍的获取就不再是问题。
信息源 虽然文章开头对于传统的书籍大赞特赞，但书籍的缺点也是显而易见的。在技术领域，这个缺点就尤为明显：时效问题。如果我们所学习的是相对比较老的领域知识，那只要读书基本上就够了。
但技术的发展日新月异，如果你想要成为知晓领域内所有新技术的那个人。你还是需要关注一些书籍以外的新闻源，下面是一些例子：
Github Trending Github Trending 代表的是一种风向，一般一个项目能上 trending 的话，可能是作者自己去 hacker news、reddit 做了宣传，也可能是被某个业界大佬带了流量。因为现在 Github 上的国人越来越多，很多国人学习技术比较显著的诉求其实只是面试(汗，一旦什么 xx interview/xx road to 架构师之类的仓库开了就会吸引一大批国人点星，近两年 trending 的质量有下跌趋势。
不过最近 Github Trending 增加了按照 Spoken Language 筛选功能，所以你可以过滤特定的语言，相对比之前还是好多了。</description>
    </item>
    
    <item>
      <title>程序员如何把控自己的职业</title>
      <link>https://pillumina.github.io/posts/programmer-career/</link>
      <pubDate>Mon, 01 Feb 2021 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/programmer-career/</guid>
      <description>这篇文章摘自陈皓（左耳朵耗子）的blog（2020/08/07上传），其中很多观点击中了我内心的想法，或许可以在我遇到方向性问题的时候给我提醒。
这篇文章的主要内容主要是我今年3月份在腾讯做的直播，主要是想让一些技术人员对世界有一个大体的认识，并且在这个认识下能够有一个好的方法成就自己。而不是在一脸蒙圈的状态下随波逐流，而日益迷茫和焦虑。直播完后，腾讯方面把我的直播形成文字的形式发了出来，我觉得我可以再做一个精编版。所以，有了这篇文章，希望对大家有帮助。
对我来说，在我二十多年的工作经历来看，期间经历了很多技术的更新换代，整个技术模式、业务模式也是一直变来变去，我们这群老程序员成长中所经历的技术比今天的程序员玩的还更杂更多。我罗列一下我学过的，而且还被淘汰掉的技术，大家先感受一下。
- MIS应用开发：FoxPro，PowerBuilder，Delphi - OA：Lotus Notes，VBScripts - 微软：ODBC/ADO，COM/DCOM，MFC/ATL，J++ - 服务器：AIX，HP-UX，SCO Unix - Web：CGI，ISAPI，SOAP - RPC：CICS，Tuxedo - J2EE：Websphere，Weblogic - DB：Sybase，Informix 我想说的是，无论过去还是今天，我们这些前浪和你们后浪所面对的技术的挑战和对技术的焦虑感是相似的，我们那个时候不但玩996，还玩封闭开发（就是一周只能回家一天）。当然，唯一好的东西，就是比起今天的程序员来说，我们那个年代没有像微信、微博、知乎，抖音这些巨大消耗你人生的东西，所以，我们的工作、生活和成长都有很效率，不会被打断、喜欢看书、Google还没有被封……当然，那时代没有StackOverlow和Github这样的东西，所以，能完成的东西或质量都一般。
当然，这里并不是想做一个比较，只是想让大家了解一下两代程序员间的一些问题各有千秋，大同小异。在整个成长过程中，其实有很多东西是相通的，其本上来说，就是下面的三件事——
第一，如果想要把控技术，应对这个世界的一些变化，需要大致知道这个世界的一些规律和发展趋势，另外还得认识自己，自己到底适合做什么？在这个趋势和规律下属于自己的发挥领域到底是什么？这是我们每个人都需要了解的。
第二，打牢基础，以不变应万变，不管世界怎样变化，我都能很快适应它。基础的重要程度对于你能够飞多高是相当有影响的，懂原理的人比不懂原理的人能做出来的事情或是能解决的问题完全是两个层级的。
第三，提升成长的效率，因为现在社会的节奏实在太快了，比二十年前快得太多，技术层出不穷，所以我们的成长也要更有效率。效率并不单指的快，效率是怎么样更有效，是有用功除以总功（参看《加班与效率》），怎么学到更有效的东西，或者怎么更有效学习，是我们需要掌握的另一关键。
下面是我这多年来的一些认识，希望对你有帮助。
世界发展趋势 我个人经历的信息化革命应该分成三个阶段：
 1990年代到2000年，这个时代MB时代，是雅虎、新浪、搜狐、网易门户网站的时代，这个时代就是ISP/ICP互联网提供商，把一些资讯数字化，然后发布到网络上。 2000年到2010年，这个时代叫GB时代，或是叫多媒体或UGC时代，上网开始变得普遍了，每个人手里的数码设备开始变得多了起来，可以上传照片，可以上传视频，甚至可以在网上做社交。 2010年到2020年，这个时代叫TB时代，这过去的十年是移动互联网时代，移动互联网只需要手机在线，不需要依靠电脑。因为手机随时在线，所以个人的各种各样的数据始终在被收集，只要用户上网就会产生数据，所以人的行为最终也被数字化了。  所有的硬件和软件都是跟着需要处理的数据而演进的，我们需要更大的带宽，更大的硬盘，更多的处理器……大到一定时候就只能进入分布式化的技术架构了，再大，数据中心也顶不住了，就会要引入更为分布式的边缘计算了。
另一方面，从业务上来看，我们可以看到整个世界就在不断地进行数字化，因为，只要数字化了，就可以进行复制传播和计算，只要可以进行计算了，就可以进行数学建模，就可以自动化，只要可以自动化了就可以规模化，只要可能规模化了，就可以改变整个行业。人类的近代史的大趋势基本上都是在解决能源和自动化的事，源源不断的能源是让机器不知疲倦的前提条件，用机器代替牲口，代替人类进行工作是规模化的前提条件。
所以，技术的演进规律基本是自动化加规模化，从而降低成本，提升效率。这就是为什么世界变得越来越快，人类都快跟不上节奏的原因，主要是整个社会不断被机器、数据所驱动。
人才需求 在这个过程中，需要什么样的人？下面是我的一些认识——
 技工，在机器和自动化面前，肯定是需要能够操作机器的技术工人了，这类人是有技术的劳动力。在编程的圈子里俗称“码农”，他们并不是真正的工程师，他们只是电脑程序的操作员，所以，随着技术门槛的下降或是技术形式的变更他可能就会变得越来越不值钱，直到被淘汰掉。 特种工，这种人是必须了解原理和解决难题的一类人，他们是解决比较难的、特定的一些技术问题。当一种技术被淘汰，他并不容易被淘汰，因为他懂原理，原理就是解决问题的能力，是解决问题的套路和方法。 工程师，不但是使用技术，还可以把活儿做好，他们认为代码更多的时间是在维护，这些人使用各种各样的手段和各种技术，精益求精地持续不断地提高代码的易读性、扩展性、可维护性和重用性，这个过程似乎永无止境。对于这些有“洁癖”，有“工匠精神”，有“修养”的技术人员，我们称他们为工程师。这种人做事又稳又快，而且可以做出很多称手的工具和方法论。 再往上是设计师和架构人员，这些人主要是开发一些工具，框架，模式，提升软件开发和维护效率，同时也提升用户体验，和提升稳定性、性能、代码重用等，总的来说就是为了降本增效。这类人的工作降低了技术得到门槛，他们把技术门槛降低了以后，就可以把这个技术普及开来，就可以由广大劳工、技工、特殊工人使用了。 还有一类人是经理，经理主要是组织团队、完成项目、创造利润。这类人中，即有身先士卒的leader，也有高高在上的boss，但无论怎么样，这些人只不过是为了让一个公司或是一个团队更好组织在一起的“粘合剂”，这类人只有在大公司中才会变成更有价值。  这就是我总结的世界需要哪些人才，我们了解这些东西以后大概就明白我们现在所处的位置有什么样的问题，我们应该去什么样的地方。
Google 评分卡 接下来，我们再来看看Google的SRE的自我评分卡：
0 – 对于相关的技术领域还不熟悉 1 – 可以读懂这个领域的基础知识 2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节。 3 – 基本精通这个技术领域，完全不需要别人的帮助 4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作。 对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识。 对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。 5 – 对于该技术领域有非常底层的了解和深入的技能。 6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构 7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作。 8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施 9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法。 10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人。 SRE需要自评如下这些技术或技能。</description>
    </item>
    
    <item>
      <title>A Million WebSocket and Go</title>
      <link>https://pillumina.github.io/posts/golang/websocket/</link>
      <pubDate>Sat, 16 Jan 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/websocket/</guid>
      <description>这篇文章是我研究高负载网络服务器架构看到的的一个有趣的story，添加了我自身学习websocket的感受和记录，希望我能在飞机落地前写完:-)
Preface 我们先描述一个问题作为讨论的中心：用户邮件的存储方法。
对于这种主题，有很多种方式在系统内对邮件状态进行持续的追踪，比如系统事件是一个方式，另一种方式可以通过定期的系统轮询有关状态变化。
这两种方式各有利弊，不过当我们讨论到邮件的时候，用户希望收到新邮件的速度越快越好。邮件轮询每秒约有50000个HTTP请求，其中60%返回304状态，也就是邮箱内没有任何修改。
因此，为了减少服务器的负载并加快向用户传递邮件的速度，我们决定通过编写publisher-subscriber服务器(即bus, message broker, event channel)来重新发明轮子。一方面接受有关状态变更的通知，另外一个方面接受此类通知的订阅。
改进前：
+--------------+ (2) +-------------+ (1) +-----------+ | | &amp;lt;--------+ | | &amp;lt;--------+ | | | Storage | | API | HTTP | Browser | | | +--------&amp;gt; | | +--------&amp;gt; | | +--------------+ (3) +-------------+ (4) +-----------+ 改进后:
+--------------+ +-------------+ WebSocket +-----------+ | Storage | | API | +----------&amp;gt; | Browser | +--------------+ +-------------+ (3) +-----------+ + ^ | (1) | (2) v + +-----------------------------------------+ | Bus | +-----------------------------------------+ 改进前的方案也就是browser定期去查询api并访问存储更改</description>
    </item>
    
    <item>
      <title>fasthttp对性能的优化压榨</title>
      <link>https://pillumina.github.io/posts/golang/fasthttp/</link>
      <pubDate>Sun, 10 Jan 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/fasthttp/</guid>
      <description>最近在看网络模型和go net的源码，以及各web框架例如fasthttp, weaver, gnet(更轻量)源码。fasthttp在github上已经写上了一个go开发的best practices examples,这里我也记录一些在源码中看到的一些技巧
[]byte buffer的tricks 下面的一些tricks在fasthttp中被使用，自己的代码也可以用
 标准Go函数能够处理nil buffer  var ( // both buffers are uninitialized 	dst []byte src []byte ) dst = append(dst, src...) // is legal if dst is nil and/or src is nil copy(dst, src) // is legal if dst is nil and/or src is nil (string(src) == &amp;#34;&amp;#34;) // is true if src is nil (len(src) == 0) // is true if src is nil src = src[:0] // works like a charm with nil src  // this for loop doesn&amp;#39;t panic if src is nil for i, ch := range src { doSomething(i, ch) } 所以可以去掉一些对[]bytebuffer的nil校验:</description>
    </item>
    
    <item>
      <title>[源码分析]sync pool</title>
      <link>https://pillumina.github.io/posts/golang/sync-pool/</link>
      <pubDate>Fri, 01 Jan 2021 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/sync-pool/</guid>
      <description>- 当多个goroutine都需要创建同一个对象，如果gorountine数过多，导致对象的创建数目剧增，进而导致GC压力增大，形成“并发大-占用内存大-GC缓慢-并发处理能力弱-并发更大”这样的恶性循环 - 在这个时候，需要一个对象池，每个goroutine不再自己单独创建对象，而是从对象池中取出一个对象（如果池中已有） </description>
    </item>
    
    <item>
      <title>[自建轮]高性能Goroutine Pool</title>
      <link>https://pillumina.github.io/posts/golang/goroutine-pool/</link>
      <pubDate>Wed, 30 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/goroutine-pool/</guid>
      <description>高性能Goroutine Pool go调度器没有限制对goroutine的数量，在goroutine瞬时大规模爆发的场景下来不及复用goroutine从而导致大量goroutine被创建，会导致大量的系统资源占用，尝试池化。
go调度器本身不应该对goroutine数量有限制，因为语言层面无法界定需要限制多少，毕竟程序跑在不同性能的环境，在并发规模不太大的场景做限制甚至会降低性能，原生支持限制goroutine数量无疑是得不偿失的。如果只是中等规模和比较小规模的并发场景其实pool的性能并没有优势
目前设计上还需要加上周期性对空闲队列的prune，等写完再加看看benchmark会提升多少。目前来说对大规模goroutine异步并发的场景(1M, 10M)内存优化(10倍往上)和吞吐量优化效果(2-6倍)非常好。
需求场景与目标  限制并发goroutine的数量 复用goroutine，减轻runtime调度压力，提升程序性能 规避过多的goroutine创建侵占系统资源，cpu&amp;amp;内存  关键技术  锁同步: golang有CAS机制，用spin-lock替代mutex 原理， 讨论 LIFO/FIFO队列: LIFO队列能直接有时间排序功能，方便对需要关联入队时间的操作进行处理 Pool容量限制和弹性伸缩  代码实现 pool.go package go_pool import ( &amp;#34;errors&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;sync/atomic&amp;#34; &amp;#34;time&amp;#34; ) const( OPEN = iota CLOSED ) var ( ErrPoolClosed = errors.New(&amp;#34;this pool has been closed&amp;#34;) ErrPoolOverload = errors.New(&amp;#34;too many goroutines blocked on submit or Nonblocking is set&amp;#34;) ErrInvalidExpiryTime = errors.New(&amp;#34;invalid expiration time&amp;#34;) ErrInvalidPoolCapacity = errors.New(&amp;#34;invalid pool capacity&amp;#34;) DefaultScanInterval = time.</description>
    </item>
    
    <item>
      <title>Possible Memory Leak</title>
      <link>https://pillumina.github.io/posts/golang/memory-leak/</link>
      <pubDate>Fri, 25 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/memory-leak/</guid>
      <description>实际上对于一个有GC的语言，我们不必太多关心内存泄漏的问题，因为程序的runtime帮我们很好地额回收不再使用的内存。但是，我们还是得了解一些特殊的场景，这些场景会产生暂时性或者永久性的内存泄漏。
待开坑...</description>
    </item>
    
    <item>
      <title>Close Channels Gracefully</title>
      <link>https://pillumina.github.io/posts/golang/channel-graceful/</link>
      <pubDate>Thu, 24 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/channel-graceful/</guid>
      <description>优雅地关闭通道 场景一：M个接收者和一个发送者。发送者通过关闭用来传输数据的通道来传递发送结束信号 这是最简单的一种情形。当发送者欲结束发送，让它关闭用来传输数据的通道即可。
package main import ( &amp;#34;time&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;log&amp;#34; ) func main() { rand.Seed(time.Now().UnixNano()) log.SetFlags(0) // ... 	const Max = 100000 const NumReceivers = 100 wgReceivers := sync.WaitGroup{} wgReceivers.Add(NumReceivers) // ... 	dataCh := make(chan int) // 发送者 	go func() { for { if value := rand.Intn(Max); value == 0 { // 此唯一的发送者可以安全地关闭此数据通道。 	close(dataCh) return } else { dataCh &amp;lt;- value } } }() // 接收者 	for i := 0; i &amp;lt; NumReceivers; i++ { go func() { defer wgReceivers.</description>
    </item>
    
    <item>
      <title>Channels Concurrency Work-Around</title>
      <link>https://pillumina.github.io/posts/golang/channels/</link>
      <pubDate>Tue, 22 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/channels/</guid>
      <description>记录了一些channels常见的场景，以及自己的一些感受：
  使用通道进行异步和并发编程是简单和惬意的；
  通道同步技术比被很多其它语言采用的其它同步方案（比如角色模型和async/await模式）有着更多的应用场景和更多的使用变种。
通道作为同步手段，并非在任何情况下都是最佳的同步技术，本文也会补充原子操作和sync包内其他的技术作为参考。
  将通道用做future/promise 很多其它流行语言支持future/promise来实现异步（并发）编程。 Future/promise常常用在请求/回应场合。
返回单向接收通道做为函数返回结果 在下面这个例子中，sumSquares函数调用的两个实参请求并发进行。 每个通道读取操作将阻塞到请求返回结果为止。 两个实参总共需要大约3秒钟（而不是6秒钟）准备完毕（以较慢的一个为准）。
package main import ( &amp;#34;time&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;fmt&amp;#34; ) func longTimeRequest() &amp;lt;-chan int32 { r := make(chan int32) go func() { time.Sleep(time.Second * 3) // 模拟一个工作负载 	r &amp;lt;- rand.Int31n(100) }() return r } func sumSquares(a, b int32) int32 { return a*a + b*b } func main() { rand.Seed(time.Now().UnixNano()) a, b := longTimeRequest(), longTimeRequest() fmt.</description>
    </item>
    
    <item>
      <title>Black Magic</title>
      <link>https://pillumina.github.io/posts/black-magic/</link>
      <pubDate>Sun, 20 Dec 2020 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/black-magic/</guid>
      <description>阅读到的一些方便、有趣的技巧或者ideas的随手记录，后续考虑对相关话题专门开坑
一行代码画出专业的论文图 SciencePlots
计算机专业向来不缺少专业的绘图软件，从Excel到PPT，从最近沸沸扬扬的Matlab到Matplotlib、pyplot、ggplot，乃至其他更为专业的软件，着实丰富了我们的画图生活。
但是，这些软件或工具的背后，常常需要我们付出更多的努力：调色、统一格式、展示要高大上，等等。
现在，一款开源的软件工具包问世了：SciencePlots。它让你用一行代码画出天然高端且美观的论文图。
SciencePlots是一个依附于Matplotlib的扩展包，可以通过pip一键安装：
pip install SciencePlots 然后我们在画图时，只需要一句with.plt.style.context([&#39;science&#39;]):，就可以画出非常美观且专业的图：
你还可以加一个选项with.plt.style.context([&#39;science&#39;,&#39;ieee&#39;]):，就能画出IEEE格式的图：
甚至是超美的散点图：
还有很多自定义的图像风格，保证节约我们的画图时间
 这个包默认会调用latex来画图，如果不想用latex（也不是完全需要），可以在context里写一个属性&amp;rsquo;nolatex&amp;rsquo;即可。不然如果没有安装latex或latex路径配置有问题，则会报错。
 </description>
    </item>
    
    <item>
      <title>Tracking</title>
      <link>https://pillumina.github.io/posts/links/</link>
      <pubDate>Sat, 19 Dec 2020 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/links/</guid>
      <description>这个post为记录目前正在阅读与研究的section
Go语言设计 Go语言设计与实现
Go Under The Hood
这两本在写作目的和内容规划都是一致的，不过第二个原本不再维护内容，作者开了下面的新的项目，把撰写原本而积累的与Go相关的资源进行了重新的整理。 Go设计历史
pprof对服务端性能影响的研究 考虑一些极端场景，比如极度追求性能，压榨系统资源以及技术栈必须是Go的业务场景下，是否能自己构建Reactor网络模型
GRPC框架对服务侧性能的影响 Russ Cox正则表达式系列 You should not be permitted to write production code if you do not have an journeyman license in regular expressions or floating point math. &amp;ndash; Rob Pike
Regular Expression Matching Can Be Simple And Fast
编译器词法分析:正则语言和正则表达式
Go内存原理与调度模型 正在整理专栏
Bound Checking Elimination Crafting Interpreter 时常看PL和Compiler的基础
crafting interpreters
Kosaraju&amp;rsquo;s Algorithm 看William Lin的coding interview觉得用来处理树和图很好，算法4里也有
Heilmeier问题系列 思考某篇paper的选题
 What are you trying to do?</description>
    </item>
    
    <item>
      <title>Golang TDD</title>
      <link>https://pillumina.github.io/posts/golang/go-testing/</link>
      <pubDate>Sat, 19 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/go-testing/</guid>
      <description>Preface 本文整理golang编码的单元测试常用示例，以及TDD的简要流程。
单元测试基础 单元测试文件以_test.go结尾，需要记住以下原则：
 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。  Table-Driven-Testing 测试讲究 case 覆盖，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。
func TestFib(t *testing.T) { var fibTests = []struct { in int // input  expected int // expected result  }{ {1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 5}, {6, 8}, {7, 13}, } for _, tt := range fibTests { actual := Fib(tt.</description>
    </item>
    
    <item>
      <title>Golang并发调度</title>
      <link>https://pillumina.github.io/posts/golang/schedualing/</link>
      <pubDate>Thu, 17 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/schedualing/</guid>
      <description>性能提升不会凭空出现，它总是伴随着代码复杂度的上升。 The performance improvement does not materialize from the air, it comes with code complexity increase.
&amp;ndash; Dmitry Vyukov
Go 语言的调度器我认为应该是整个运行时最有趣的组件了。对于Go本身，它的设计和实现直接牵动了Go运行时的其他组件，也是和用户态代码直接打交道的部分；对于Go用户而言，调度器将其极为复杂的运行机制隐藏在了简单的关键字go下。为了保证高性能，调度器必须有效得利用计算的并行性和局部性原理；为了保证用户态的简洁，调度器必须高效得对调度用户态不可见的网络轮训器、垃圾回收器进行调度；为了保证代码执行的正确性，必须严格实现用户态代码的内存顺序等。总而言之，调度器的设计直接决定了Go运行时源码的表现形式。
设计原理 数据结构: MPG 调度器启动 创建Goroutine 调度循环 触发调度 线程管理 总结 </description>
    </item>
    
    <item>
      <title>Python类自定义</title>
      <link>https://pillumina.github.io/posts/python/python-functionality/</link>
      <pubDate>Mon, 14 Dec 2020 16:20:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/python/python-functionality/</guid>
      <description>python类关键字 __init__ vs __new__ __init__为初始化方法，__new__为真正的构造函数。
描述符Descriptor __contains__ __slots__ 定制类 type() python作为动态语言，和静态语言最大的不同，即函数和类的定义，不是编译的时候创建的而是动态创建的。我们常见的对类的定义:
class Hello(object): def hello(self, name=&amp;#39;world&amp;#39;): print(&amp;#39;Hello, %s.&amp;#39; % name) &amp;gt;&amp;gt;&amp;gt; from hello import Hello &amp;gt;&amp;gt;&amp;gt; h = Hello() &amp;gt;&amp;gt;&amp;gt; h.hello() Hello, world. &amp;gt;&amp;gt;&amp;gt; print(type(Hello)) &amp;lt;class &#39;type&#39;&amp;gt; &amp;gt;&amp;gt;&amp;gt; print(type(h)) &amp;lt;class &#39;hello.Hello&#39;&amp;gt; type()函数可以查看一类类型或者变量的类型，Hello是一个class， 它的类型是个type，而h是一个instance, 它的类型就是class Hello。
同时有一个概念，就是type()不仅可以返回对象的类型，还可以创建出新的类型。我们可以不用定义class Hello() ...而动态创建出Hello类。
&amp;gt;&amp;gt;&amp;gt; def fn(self, name=&#39;world&#39;): # 先定义函数 ... print(&#39;Hello, %s.&#39; % name) ... &amp;gt;&amp;gt;&amp;gt; Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn)) # 创建Hello class &amp;gt;&amp;gt;&amp;gt; h = Hello() &amp;gt;&amp;gt;&amp;gt; h.</description>
    </item>
    
    <item>
      <title>BDD: Ginkgo测试框架</title>
      <link>https://pillumina.github.io/posts/golang/bdd-testing-framework/</link>
      <pubDate>Fri, 04 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/bdd-testing-framework/</guid>
      <description>Preface BDD和TDD都是test case first的实现，无非是把后者的test改成前者的behavior。在TDD中，关注的核心点是function，即认为程序最基本单元是function，其test case可以认为是unit test，TDD和unit test的区别是TDD强调测试和开发结合而成的工作流: 写test case -&amp;gt; 写代码 -&amp;gt; 通过测试，继续写更多测试，写一次循环。
而BDD比TDD更关注高层的行为，而不是函数级别的行为，也就是在BDD中，不会强调函数的功能正确，这是unit test应该做的事。BDD更关注user story，即用户在特定场景，与软件交互发生的行为，这个behavior指的就是高层模块的行为。
如何区分BDD和TDD，简单理解，TDD是给programmer的，用来验证开发者的最基本模块的功能：在什么输入，应该产生什么输出，保证实现的边界，健全性。而BDD，其test case描述的是更高级的模块行为，脱离了具体的实现，容易用自然语言去描述，也就是BDD是给product manager的，告诉其系统的行为。
BDD in golang ​	实现的时候，我们需要把Given-When-Then这种story格式组织test case翻译为测试代码，通过一系列的assertion来检查实现是否符合test case的预期，我们完全可以直接通过golang自带的testing模块来实现，不过testing的功能有时候比较简陋，本文记录了用Ginkgo+Gomega来组织test case，让我们的测试语言更加接近自然语言。
二者结合的目的是，ginkgo实现了test case的组织，并加入了其他方便的功能: 初始化，后续处理，异步等等。而gomega设计的目的是与ginkgo一起工作，实现易读的assertion(ginkgo中称为match)功能。
Gomega is ginkgo&#39;s preferred matcher library 初始化 ginkgo依托golang原生testing框架，即可以用go test ./.. 执行，也可以通过ginkgo binrary安装go install github.com/onsi/ginkgo，封装了ginkgo测试框架的各种feature。
初始化首先进入待测试的package:
cd /path/to/package 执行初始化:
ginkgo bootstrap 生成以suite_test.go文件，接下来向suite添加测试specs，生成比如ginkgo_cart package测试文件。
ginkgo generate ginkgo_cart 运行 生成ginkgo_cart_test.go，注意测试文件在ginkgo_cart_testpackage， 需要import package ginkgo_cart，即BDD层级高于unit test, 不应该了解package内部的具体实现，测试package的外部接口即可。编写测试代码，运行go test ./..即可。
Ginkgo Keyword Ginkgo测试代码骨架由一系列keyword关联的闭包组成，常用的有：
 Describe/Context/When: 测试逻辑块 BeforeEach/AfterEach/JustBeforeEach/JustAfterEach: 初始化测试用例块 It: 单一Spec，测试case  keyword的声明均为传入Body参数，比如Describe:</description>
    </item>
    
    <item>
      <title>Golang内存管理</title>
      <link>https://pillumina.github.io/posts/golang/memory-management/</link>
      <pubDate>Wed, 02 Dec 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/memory-management/</guid>
      <description>设计原则 现在我们来看 Go 中另一重要的关键组件：内存分配器。
Go 的内存分配器基于 Thread-Cache Malloc (tcmalloc) ，tcmalloc 为每个线程实现了一个本地缓存， 区分了小对象（小于 32kb）和大对象分配两种分配类型，其管理的内存单元称为 span。
我们不再介绍更多 tcmalloc 的具体细节，因为 Go 的内存分配器与 tcmalloc 存在一定差异。 这个差异来源于 Go 语言被设计为没有显式的内存分配与释放， 完全依靠编译器与运行时的配合来自动处理，因此也就造就了内存分配器、垃圾回收器两大组件。
我们知道，在计算机领域中，无外乎时间换空间、空间换时间。统一管理内存会提前分配或一次性释放一大块内存， 进而减少与操作系统沟通造成的开销，进而提高程序的运行性能。 支持内存管理另一个优势就是能够更好的支持垃圾回收，这一点我们留到垃圾回收器的章节中进行讨论。
主要结构 Go 的内存分配器主要包含以下几个核心组件：
 heapArena: 保留整个虚拟地址空间 mheap：分配的堆，在页大小为 8KB 的粒度上进行管理 mspan：是 mheap 上管理的一连串的页 mcentral：收集了给定大小等级的所有 span mcache：为 per-P 的缓存。  其中页是向操作系统申请内存的最小单位，目前设计为 8KB。
每一个结构虽然不都像是调度器 M/P/G 结构那样的大部头，但初次阅读这些结构时想要理清他们之间的关系还是比较麻烦的。 传统意义上的栈被 Go 的运行时霸占，不开放给用户态代码；而传统意义上的堆内存，又被 Go 运行时划分为了两个部分， 一个是 Go 运行时自身所需的堆内存，即堆外内存；另一部分则用于 Go 用户态代码所使用的堆内存，也叫做 Go 堆。 Go 堆负责了用户态对象的存放以及 goroutine 的执行栈。
Arena heapArena Go 堆被视为由多个 arena 组成，每个 arena 在 64 位机器上为 64MB，且起始地址与 arena 的大小对齐， 所有的 arena 覆盖了整个 Go 堆的地址空间。</description>
    </item>
    
    <item>
      <title>Golang逃逸分析</title>
      <link>https://pillumina.github.io/posts/golang/golang-escape-analysis/</link>
      <pubDate>Mon, 23 Nov 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/golang/golang-escape-analysis/</guid>
      <description>问题： golang函数传参是不是应该和c一样，尽量不要直接传结构体，而是要传结构体指针？
逃逸分析 逃逸分析指的是，在计算机语言编译器优化原理中，分析指针动态范围的方法，和编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中被分配后，其指针有可能被返回或者被全局引用，这种现象就是指针（或引用）的逃逸（Escape）。
其实在java概念中有一个误解 &amp;mdash; new出来的东西都在堆上，栈上存的是它的引用。 这句话在现代JVM上有问题，就是因为逃逸分析机制。简单来说，就是JVM的逃逸分析会在运行时(runtime)检测当前方法栈帧(frame)内new出来的对象的引用，是否被传出当前的栈帧。如果传出，就会发生逃逸，没有传出则不会。对于未发生逃逸的变量，则会直接在栈上分配内存。因为栈上内存由在函数返回时自动回收，而堆上的的内存需要gc去回收，如果程序中有大量逃逸的对象，那么势必会增加gc的压力。
public void test(){ List&amp;lt;Integer&amp;gt; a = new ArrayList&amp;lt;&amp;gt;(); a.add(1); // a 未逃逸，在栈上分配 } public List&amp;lt;Integer&amp;gt; test1(){ List&amp;lt;Integer&amp;gt; a = new ArrayList&amp;lt;&amp;gt;(); a.add(1); return a // 发生逃逸，因此分配在堆上 } 区别  不同于JVM运行时的逃逸分析，Golang的逃逸分析是在编译期完成。 golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。  go version go1.13.4 darwin/amd64 验证某个函数的变量是否发生逃逸的方法：
  go run -gcflags &amp;ldquo;-m -l&amp;rdquo; (-m打印逃逸分析信息，-l禁止内联编译)
  go tool compile -S xxxx.go | grep runtime.newobject（汇编代码中搜newobject指令，这个指令用于生成堆对象）
  备注： 关于-gcflags &amp;ldquo;-m -l&amp;quot;的输出，有两种情况：
 Moved to heap: xxx xxx escapes to heap  二者都表示发生了逃逸，当xxx变量为指针的时候，出现第二种；当xxx变量为值类型时，为上一种，测试代码：</description>
    </item>
    
    <item>
      <title>Design Pattern: Overview</title>
      <link>https://pillumina.github.io/posts/design-pattern/design-pattern/</link>
      <pubDate>Wed, 11 Nov 2020 11:22:18 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/design-pattern/design-pattern/</guid>
      <description>Design pattern Builder Pattern scenario：build complicated object package msg type Message struct { Header *Header Body *Body } type Header struct { SrcAddr string SrcPort uint64 DestAddr string DestPort uint64 Items map[string]string } type Body struct { Items []string } // Message对象的复杂对象 type builder struct{ once *sync.Once msg *Message } // 返回Builder对象 func Builder() *builder{ return &amp;amp;builder{ once: &amp;amp;sync.Once{}, msg: &amp;amp;Message{Header: &amp;amp;Header{}, Body: &amp;amp;Body{}}, } } func (b *builder) WithSrcAddr(srcAddr string) *builder{ b.</description>
    </item>
    
    <item>
      <title>MIT distributed system</title>
      <link>https://pillumina.github.io/open_courses/my-first-note/</link>
      <pubDate>Tue, 27 Oct 2020 10:40:12 +0800</pubDate>
      
      <guid>https://pillumina.github.io/open_courses/my-first-note/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java Fundamentals</title>
      <link>https://pillumina.github.io/posts/java/java-fundamentals/</link>
      <pubDate>Mon, 26 Oct 2020 12:40:29 +0800</pubDate>
      
      <guid>https://pillumina.github.io/posts/java/java-fundamentals/</guid>
      <description>JAVA对象的equals方法和hashCode方法是这样规定的   相等（相同）的对象必须有相等的哈希码
  如果两个对象的哈希吗相同，它们不一定相同
  Java集合判断两个对象是否相等的规则：   判断两个对象的哈希码是否相等
  判断两个对象用equals是否相等
  所以重写其中一个方法，必须重写另一个方法
让对象可拷贝：
 实现java.lang.Cloneable 2. 重写Object的clone()方法  由于GC的自动回收机制，并不能保证finalize方法被及时的执行，因为对象的回收时机具有不确定性，或者要么没有触发垃圾回收。这个方法被禁止调用，应该用显式的close()方法。 Collection类的选择 Set:
排序吗？
是： TreeSet / LinkedHashSet
否： HashSet
List
要安全吗？
是： Vector
否： ArrayList或者LinkedList &amp;mdash; 查询多ArrayList，增删多LinkedList
Map常用子类：HashMap, HashTable, TreeMap, ConcurrentHashMap HashMap: 非线程安全，性能高，基于数组和链表实现。
TreeMap：有序键值对，按key排序
HashTable: 线程安全, 性能低
ConcurrentHashMap: 线程安全且性能较好。Java1.7采取分段锁，1.8采用CAS+synchronized保证并发安全。
LinkedHashMap 为HashMap的子类，内部还有一个双向链表维护键值对的顺序。支持插入顺序、访问顺序
  插入顺序：先添加在前，后添加在后
  访问顺序：即get/put操作，对一个键执行get/put操作后，对应的键值被移动到链表的末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的。
  有5种构造方法，4个是插入顺序，只有一个按照指定访问顺序，可以用于实现LRUCache
  集合初始化、大小和扩容 建议在集合初始化时指定集合容量大小 如果没有设置，元素增加，resize表会重建hash，影响性能</description>
    </item>
    
  </channel>
</rss>
