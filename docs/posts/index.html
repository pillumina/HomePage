<!DOCTYPE html>
<html>
  <head>
    <title>Posts</title>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />


<link rel="stylesheet" href="/assets/css/bootstrap.min.css"/>
<link rel="stylesheet" href="/assets/css/layouts/main.css"/>
<link rel="stylesheet" href="/assets/css/style.css"/>
<link rel="stylesheet" href="/assets/css/navigators/navbar.css"/>


<link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" />


<link rel="icon" type="image/png" href="/assets/images/favicon.png" />


<link rel="stylesheet" href="/assets/css/style.css"/>

    
    <link rel="stylesheet" href="/assets/css/layouts/list.css">
    <link rel="stylesheet" href="/assets/css/navigators/sidebar.css">


    
    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-190574896-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
  </head>

  <body data-spy="scroll" data-target="#TableOfContents" data-offset="80">
    <div class="container-fluid bg-dimmed wrapper">
      
      
    


  


  


<nav class="navbar navbar-expand-xl top-navbar final-navbar shadow">
  <div class="container">
      <button class="navbar-toggler navbar-light" id="sidebar-toggler" type="button" onclick="toggleSidebar()">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/">
      <img src="/assets/images/main-logo.png">CctoctoFX</a>
    <button class="navbar-toggler navbar-light" id="toc-toggler" type="button" onclick="toggleTOC()">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse lang-selector" id="top-nav-items">
      <ul class="navbar-nav ml-auto">
      
      </ul>
    </div>
  </div>
  
  <img src="/assets/images/main-logo.png" class="d-none" id="main-logo">
  <img src="/assets/images/inverted-logo.png" class="d-none" id="inverted-logo">
</nav>



      
      
  
  

  <section class="sidebar-section" id="sidebar-section">
    <div class="sidebar-holder">
      <div class="sidebar" id="sidebar">
        <input type="text" value="" placeholder="Search" data-search="" id="search-box" />
        <div class="sidebar-tree">
          <ul class="tree" id="tree">
            <li id="list-heading"><a href="https://pillumina.github.io/posts" data-filter="all">Posts</a></li>
            <div class="subtree">
                
  
  
  
  
  
    
    <li><a class="" href="/posts/black-magic/">Black Magic</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/iaas-paas-diff/">IaaS vs PaaS vs SaaS</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/links/">Tracking</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/do-not-wall/">别让自己墙了自己</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/how-to-learn/">工程师应该如何高效学习</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/programmer-career/">程序员如何把控自己的职业</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/algo/">FX算法笔记</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/golang/">Golang Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/golang/channels/">Channels Concurrency</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/fasthttp/">fasthttp对性能的优化研究</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/bdd-testing-framework/">Ginkgo 测试框架</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/lifecycle-of-http/">Go server中http请求的生命周期</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/go-testing/">Golang Testing Kits</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/memory-management/">Golang内存管理</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/schedualing/">Golang并发调度</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/golang-escape-analysis/">Golang逃逸分析</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/goroutine-pool/">Goroutine Pool</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/websocket/">Million WebSocket</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/go-profiling/">Profling Go Service</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/sync-pool/">Sync Pool源码分析</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/channel-graceful/">优雅关闭通道</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/memory-leak/">可能的内存泄漏场景</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/java/">Java Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/java/java-fundamentals/">Java Fundamentals</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/cloud-computing/">Kubernetes &amp; Docker</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-basic/">Docker Cheat Sheet</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-namespace/">Docker Fundamentals (Namespace)</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/k8s-basic/">Kubernetes Handbook (Start &amp; Pod)</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/notes/">Notes</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/notes/my-first-note/">MIT distributed system courses</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/design-pattern/">Programming Pattern</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/design-pattern/">Design Pattern Overview</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/go-pipeline/">Go Pipeline Pattern</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/go-visitor/">Go Visitor Pattern (k8s)</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/python/">Python Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/python/python-functionality/">Python类自定义</a></li>
  


      </ul>
    </li>
  


            </div>
          </ul>
        </div>
      </div>
    </div>
  </section>


      
      
<section class="content-section" id="content-section">
  <div class="content container-fluid" id="content">
    <div class="container-fluid post-card-holder" id="post-card-holder">
      
      
        <div class="post-card">
  <a href="/posts/cloud-computing/docker-namespace/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Docker Fundamentals: Namespace</h5>
        <p class="card-text post-summary">容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。
有时候我认为自己的阅读比较碎片化(short-term memory越来越少)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。
什么是Namespace 简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。
这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。
Linux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：
   分类 系统调用参数 相关内核版本     Mount namespaces CLONE_NEWNS Linux 2.4.19   UTS namespaces CLONE_NEWUTS Linux 2.6.19   IPC namespaces CLONE_NEWIPC Linux 2.6.19   PID namespaces CLONE_NEWPID Linux 2.6.24   Network namespaces CLONE_NEWNET 始于Linux 2.6.24 完成于 Linux 2.6.29   User namespaces CLONE_NEWUSER 始于 Linux 2.6.23 完成于 Linux 3.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">April 1, 2021</span>
        <a
        href="/posts/cloud-computing/docker-namespace/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/design-pattern/go-visitor/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang-banner-2.png'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Go编程模式：Visitor（k8s）</h5>
        <p class="card-text post-summary">概述 最近在看kubernetes的kubectl部分源码，记录一下其中用到的visitor编程模式(实际上kubectl主要用到了builder和visitor)。visitor模式是将算法和操作对象结构分离的一种方法。换句话说，这样的分离能够在不修改对象结构的情况下向原有对象新增操作，是符合开闭原则的。这个文章以一些例子去讨论kubectl中到底如何玩的。
从一个例子出发 写一个简单的Visitor模式示例：
 我们的代码中有一个Visitor的函数定义，还有一个Shape接口，其需要使用 Visitor函数做为参数 我们的实例的对象 Circle和 Rectangle实现了 Shape 的接口的 accept() 方法，这个方法就是等外面给我传递一个Visitor。  package main import ( &#34;encoding/json&#34; &#34;encoding/xml&#34; &#34;fmt&#34; ) type Visitor func(shape Shape) type Shape interface { accept(Visitor) } type Circle struct { Radius int } func (c Circle) accept(v Visitor) { v(c) } type Rectangle struct { Width, Heigh int } func (r Rectangle) accept(v Visitor) { v(r) } 然后，我们实现两个Visitor，一个是用来做JSON序列化的，另一个是用来做XML序列化的:
func JsonVisitor(shape Shape) { bytes, err := json.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">March 31, 2021</span>
        <a
        href="/posts/design-pattern/go-visitor/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/k8s-basic/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Kubernetes Handbook (Start &amp; Pod)</h5>
        <p class="card-text post-summary">使用minikube构建本地单节点k8s集群  minikube ssh kubectl cluster-info kubectl get nodes #查看节点信息 kubectl describe node minikube #详细信息  多节点k8s集群，使用Google K8s Engine 构建方式看GKE官网即可
k8s初步使用 kubectl run kubia &ndash;image=derios/kubia &ndash;port=8080 &ndash;generator=run/v1
 --image=derios/kubia代表要运行的容器镜像 这里的--generator会被废弃，其含义指代的是创建一个ReplicationController而不是Deployment。 kubectl apply -f 更常用 kubectl get pods kubectl get pods -o wide 显示pod ip和pod的节点 如果使用GWE，可以访问集群的dashborad: kubectl clusert-info获取地址 gcloud container clusters describe kubia | grep -E &ldquo;(username|password):&ldquo;获取用户名和密码 如果仅仅使用minikube，则如下不需要任何凭证即可访问:  minikube dashboard 创建服务对象，访问Web应用 如果使用minikube或者kubeadm等自定义k8s，loadbalancer是没有集成的，需要AWS或者Google Cloud。最好使用NodePort或者Ingress Controller。如果真要用minikube, 可以使用minikube tunnel解决, 或者minikube service kubia-http
  kubectl expose rc/po/svc kubia &ndash;type=LoadBalancer &ndash;name kubia-http创建出的service介于pod和node之间, kubectl get services可以查看</p>
      </div>
      <div class="card-footer">
        <span class="float-left">March 31, 2021</span>
        <a
        href="/posts/cloud-computing/k8s-basic/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/docker-basic/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Docker Cheat Sheet</h5>
        <p class="card-text post-summary">Books Docker in Action (English ver.)
Docker入门到实践(中文)
速查 Docker Cheat Sheet
全量CLI 容器管理CLI 查看容器CLI 容器交互CLI 镜像管理CLI 镜像传输CLI DOCKERFILE主要命令 Dockerfile 基底 FROMruby:2.2.2变量 ENV APP_HOME/myappRUN mkdir $APP_HOME初始化 RUN bundle installWORKDIR/myappVOLUME [&#34;/data&#34;]# Specification for mount pointADD file.xyz /file.xyzCOPY --chown=user:group host_file.xyz /path/container_file.xyzOnbuild ONBUILD RUN bundle install# when used with another file命令 EXPOSE5900CMD [&#34;bundle&#34;, &#34;exec&#34;, &#34;rails&#34;, &#34;server&#34;]Entrypoint ENTRYPOINT exec top -bMetadata LABEL version=&#34;1.0&#34;LABEL &#34;com.example.vendor&#34;=&#34;ACME Incorporated&#34;LABEL com.example.label-with-value=&#34;foo&#34;LABEL description=&#34;This text illustrates \ that label-values can span multiple lines.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">March 30, 2021</span>
        <a
        href="/posts/cloud-computing/docker-basic/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/go-profiling/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Profiling a Go Service in Production</h5>
        <p class="card-text post-summary">Pro</p>
      </div>
      <div class="card-footer">
        <span class="float-left">March 4, 2021</span>
        <a
        href="/posts/golang/go-profiling/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/lifecycle-of-http/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Life of an HTTP request in a Go server</h5>
        <p class="card-text post-summary">这篇文章的启发是我在阅读Go的http源码时获得的，之前对这块缺乏深入的了解，这篇文章会结合源码讨论包括典型http request的路由，还会涉及到一些并发和中间件的issue。
我们先从一个简单的go server谈起，下面的代码从https://gobyexample.com/http-servers 截取：
package main import ( &#34;fmt&#34; &#34;net/http&#34; ) func hello(w http.ResponseWriter, req *http.Request) { fmt.Fprintf(w, &#34;hello\n&#34;) } func headers(w http.ResponseWriter, req *http.Request) { for name, headers := range req.Header { for _, h := range headers { fmt.Fprintf(w, &#34;%v: %v\n&#34;, name, h) } } } func main() { http.HandleFunc(&#34;/hello&#34;, hello) http.HandleFunc(&#34;/headers&#34;, headers) http.ListenAndServe(&#34;:8090&#34;, nil) } 追踪请求的生命周期我们从http.ListenAndServe这个方法开始，下面的图示说明了这一层的调用关系:
这里实际上inlined了一些代码，因为初始的代码有很多其他的细节不好追踪。
主要的flow其实和我们预期的一致：ListenAndServe方法对你一个目标地址监听一个TCP端口，而后循环不断接受新的连接。每一个连接，它会起一个新的goroutine去serve，serve的具体操作是:
 从连接里解析HTTP请求： 产生http.Request 将http.Request传给用户自定义的handler  一个handler实际上就是实现了http.Handler接口：
type Handler interface { ServeHTTP(ResponseWriter, *Request) } 默认Handler 在我们上述的代码中，ListenAndServe方法的第二个参数为nil，实际上应该是用户自定义的handler, 这是为何？我们的图解中省去了很多细节，实际上当HTTP包serve一个请求的时候，它并没有直接调用用户的handlers而是使用一个adaptor：</p>
      </div>
      <div class="card-footer">
        <span class="float-left">February 20, 2021</span>
        <a
        href="/posts/golang/lifecycle-of-http/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/iaas-paas-diff/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/hero-google.svg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">IaaS vs PaaS vs SaaS</h5>
        <p class="card-text post-summary">如果你在考虑将你的在线电子业务转移到云上，下面三个名词会经常遇到：
 IaaS PaaS SaaS  这些是云计算领域的三个主要类别
你很可能早就听说过它们，在各种各样的业务转移到云上的趋势下，它们各自占据的不同的比例：
 SaaS占据大概24%的企业负载 IaaS在12%左右波动 PaaS是近年来最流行的模型，大概占据32%，且当下和未来会有更多的增长  On-Premise, SaaS, PaaS, IaaS的关键区别 on-premise这里理解成本地部署的含义，比如企业内部部署的CRM软件系统，其反义词即为云端
不久以前，所有公司的IT系统都是on-premise的，云的概念比较模糊和遥远。
SaaS, PaaS, IaaS只是三种简单描述你如何为你的业务使用云设施的方式：
 IaaS: cloud-based services, 为存储、网络以及虚拟化等服务提供pay-as-you-go PaaS: 通过internet提供硬件和软件工具 SaaS: 完全由第三方提供的软件服务 On-Premise: 企业内部部署  下面是一个图解：
SaaS, PaaS, IaaS 举例 大多数的业务一般使用SaaS以及IaaS云计算服务模型的组合，此外有很多业务会鼓励开发者使用PaaS去构建应用。
SaaS举例： BigCommerce, Google Apps, Salesforce, Dropbox, MailChimp, ZenDesk, DocuSign, Slack, Hubspot.
PaaS举例： AWS Elastic Beanstalk, Heroku, Windows Azure (mostly used as PaaS), Force.com, OpenShift, Apache Stratos, Magento Commerce Cloud.
IaaS举例： AWS EC2, Rackspace, Google Compute Engine (GCE), Digital Ocean, Magento 1 Enterprise Edition*.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">February 16, 2021</span>
        <a
        href="/posts/iaas-paas-diff/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/design-pattern/go-pipeline/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang-banner-2.png'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Go编程模式：Pipeline</h5>
        <p class="card-text post-summary">概述 这篇文章介绍Go编程里的Pipeline模式。如果是对Unix/Linux命令行熟悉的人会知道，Pipeline其实就是把每个命令拼接起来完成一个组合功能的技术。当下诸如流式处理，函数式编程，以及应用Gateway对微服务进行简单API编排，其实都受pipeline技术方式的影响。换句话说，这种技术能够很容易得把代码按照单一职责的原则拆分成多个高内聚低耦合的小模块，然后拼装起来去完成比较复杂的功能。
​</p>
      </div>
      <div class="card-footer">
        <span class="float-left">February 3, 2021</span>
        <a
        href="/posts/design-pattern/go-pipeline/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/do-not-wall/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/hero-google.svg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">别让自己墙了自己</h5>
        <p class="card-text post-summary">这篇文章摘自陈皓（左耳朵耗子）的blog（2019/12/01上传），作为给自己的提醒。
这一两周与几个朋友聊天，有年轻的90后，也有大叔级的70后，这些人在我看来都是很有能力的人，但是一些喜好过于强烈，让我不经意地回顾了我工作20年来身边的人，有发展得好的，也有发展的不好的，有些人是很可惜的，因为限制他们的不是其它人，也不是环境，而是自己，所以，很想写下这篇文章。（注：这篇文章可能会是一篇说教的文章，所以，可能会让你看着犯困，所以，我会尽量地短一些，而且尽可能多讲故事，少道理，这里的故事，全是真实发生的）
几个故事 2019年年初，我面试了一个很年轻的小伙子（93/94年出生），这个小伙子特别有灵性，也很聪明，计算机专业出身，也很喜欢技术，基础和学习能力也很好。在我这20年来认识的人中，如果他能呆在北京、上海、深圳这样的城市，我保证不出三年，他会成为他们同龄人中非常出色的技术人员，如果有个好的舞台有一个好的团队带他，他的未来会非常成功。然而，这个小伙子有两大喜好：1）只愿（或是说被迫）呆在一个毫无IT的环境的三/四线城市，2）对技术有非常大的偏好，只喜欢Go语言，非常不喜欢其它的语言，比如：Java（离开Java的世界，基本上离开了做架构的世界（相关解释见文末））。
他的这两个喜好，足以让一个未来会很优秀的人毁掉，因为，这个时代没有限制他，他的能力也没有限制他，但是他的意识完完全全地限制了他。
 他把自己最宝贵的青春放在了很烂的项目上，就算能用一些新的技术，他也只能算是自娱自乐，在实验室中玩玩具罢了。 他把自己的技术栈封闭起来，而直接放弃了这个时代最具工业化的技术Java，对于一个好的程序员来说，同时掌握几门语言和技术完全是没什么问题，但是自己封闭了自己的视野。  实在是非常可惜，我本来是可以为他介绍到一些很不错的公司的，但是他这样的习性，等于自己把自己未来的门给关上了，虽然我跟他长谈过，但是我也没有办法叫醒不想醒的人……
 视野、环境和舞台，对一个人的限制是非常大的。井蛙不知道大海，被空间维度所限制；夏虫不知道冬天，是被时间维度所限制；圈养的动物没有斗志，是被自己意识所限制。 偏见和不开放，对一个人的限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己的能力阉割掉，这是一件令人痛心的事。想想大清的闭关锁国是如何让亚洲第一的北洋水师给毁掉的……  我还有个同学，他的技术并不差，就算呆在昆明这种很落后的地方，他也非常地好学，学习英文，学习各种新技术，对技术没有任何的偏好，喜欢C/C++/Java/Python/Shell，同样喜欢前端Javascript，对基础知识非常地踏实，他在技术上没有限制自己的潜力，有什么就学什么。后来，我带他玩Docker/Go/K8S……分布式架构，他也上手的很快……像他这样的人，技术能力完全没得说，比我还大一岁，44岁了，还是一样的天天追代码细节，看Youtube的各种大会，翻github里的各种issue和pull request……
我同学这人，拥有了成为一个技术牛人几乎所有的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点……然而，只有一个小问题，就是没有到大公司历练过，我三番五次叫他从昆明出来，但是最终他都呆在昆明这个城市没有出来，因为有所谓的家庭约束。然而，我身边还有好些人，把自己家从北京搬到上海，从上海搬到深圳，从厦门搬到深圳……这样的人大有人在……像他这样的能力，在哪个公司都会是主力和骨干，对于一个公司的主力和骨干来说，家庭上的这些问题都是小问题都是有很多解的……
另外，我这个同学还是一个比较悲观的人，任何事情都是先想到不好的事，他关注负面的东西会胜于正面的东西，而且他还有一定的社交恐惧，怕与人相处和交流，时间越长越害怕，甚至有时候直接跟我说，“我就是不想改变”这样的话……其实，我以前也是一个很害怕与人交流的人，面试的时候，我根本不敢正眼看面试官一眼，也不知道与人怎么交流。但是，我与他不一样，我努力克服，不断地面试，与人面对面的交流，到一线技术客服接用户的电话，在公司里做分享，慢慢地到外面分享……3-5年就完全克服掉了。
其实，很多事情，完全是有解的，也没有必要担心，自己的心理障碍也是可以克服的，重点就是自己愿不愿意，只要愿意完成了一半，接下来就是不断的摸爬滚打坚持了。
 不限制自己的人，会穷举各种方法来解决问题，限制自己的人，只会找各式各样的问题或借口。 不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人，会放任自己。  另外几个故事 我还有另外几个故事（活到四十多，能看到好多人十几年的发展过程，感觉有点上帝视角了）
我还有一个以前团队里的一个小伙，人是很聪明，但就完全就是野路子，他对技术没有什么偏好，一个PHP程序员，做那个Discuz!论坛，公司被并购了，转成Java，开始研究Java的各种细节，对技术从来没有什么偏见，有什么就玩什么，每做一个项目，就算是一样的他都要用新的技术做一遍，然后跟着我做云计算，我教他TCP，教他C/C++，后来一起玩Docker/Go，等等，反正是一点就通，他是我见过学习能力最强的人。但是，有一个事他一直与我的想法不一样，就是我希望他先把软件设计好，再写代码，他非常不能理解，他习惯于直接动手开干，然后有什么问题就整什么问题，我也很难教育他。
有一天，他电话面了一下Facebook，电话面了15分钟后对方就放弃了，他受到了严重的打击。然后，他就开始找菲利宾人练英文口语了，我也让他做算法题，然后，他才发现，一道连算法都不是的纯编程题都提交几次都过不了，等他做完了Leetcode最初的那151道题后，整个人都改变了，写代码前认认真真地在纸上把程序的状态，处理时序以及可能遇到的一些条件先罗列出来，然后，进行逻辑设计后，再写，从此，他就开启他更大的天地了。我后来把他推荐给了微软，先在中国的Bing，在中国升好2-3级，然后去了美国的Azure，现在听说他准备要跟 k8s 的 co-founder Brendan Burns 混了（虽然，他现在还在印度人手下，但是，我真的不知道他未来能玩多大，因为今年他才33岁，而且非常聪明）
 他以前是把自己封闭起来的，我叫他出来，他也不出来，后来因为一些办公室政治的原因不得不来找我，于是我就带着他玩了两年，跟他讲了很多外面的世界是怎么玩的，他这个人也是一个相当不善于社交的人，但是心是开放的，愿意接受新的东西，虽然对技术也有一定偏见，比如不喜欢Windows，但是也不会不喜欢到完全封闭。后来我跟他说，微软的技术相当的强的，你看到的技术只是表面，深层次的东西都是相通的，直到他到了微软后发现各种牛逼的东西，对微软系统的技术的态度也有了改变，而且我让他跟我说很多微软那边的事，我发现，他对技术了解的维度已经是越来越高级的了……  还是我以前团队的一个小伙，他是一个前端，他说前端的东西没什么意思，想来找我做后端，我也一点点带他……后来，我说，你如果想要玩得好，你必需来北京，无论现在你觉得过得有多好，你都要放弃掉，然后，尽最大可能出去经历一下世界最顶尖的公司，我甚至跟他说，如果他女朋友不跟来的话，就先分开一段时间，先自己立业，他来北京的时候，他之前的同事都等着看他的笑话，我说，那些人连想都不敢想，不必管他们。于是，他去了Amazon，再过了一年去了西雅图，我跟他说，接下来就是去AWS，然后，如果有足够的野心，用自己的年轻这个资本去硅谷创业公司赌一把……未来他怎么样我不知道，但至少他没有限制自己，他的未来不会有封顶……
也是我的同学，我跟他在大学是上下铺，后来他去了人民大学读计算机博士，大学的时候做国产数据库kingbase，然后去了一家外企，天天被派到用户那边做数据分析，后来，他想回科研单位做国产数据库，我说，别啊，你的技术比我好太多，还有博士理论加持，你不去国外顶尖公司玩玩，你不知道自己有多强的，于是他跟公司申请去了国外做核心，后来因为Hadoop的原因，公司的产品最终成为了历史，于是我说，你来了美国么，你一定要去AWS，于是他就去了AWS的Aurora团队，成为了AWS明星级产品的中坚力量，天天在改MySQL的核心源码，干了两年，正在晋升 Principal Software Engineer ……
这里我到不是说出国有多牛，也许你只关注能挣多少钱，但是我想说，他们之所以能有这样的际遇，除了他们本来就有实力，还更因为他们从来不给自己设制什么限制，就是那种“艺多不压身”，有什么就学什么，有更高的就去向更高的迈进，其它的像家庭什么的问题其实都是会有解的，真的不必担心太多……
别限制了自己 上面的这些故事，也许你能看得懂，也许你看得不一定能懂，这里，让我来做个总结吧
 做有价值的事。这个世界对计算机人才的要求是供不应求的，所以，不要让自己为自己找各式各样的借口，让自己活在“玩玩具”、“搬砖”和“使蛮力加班”的境地。其实，我发现这世界上有能力的人并不少，但是有品味的人的确很少。所谓的有价值，就是，别人愿付高价的，高技术门槛的，有创造力的，有颠覆性的…… 扩大自己的眼界，开放自己的内心。人要变得开放，千万不要做一个狭隘的民族主义者，做一个开放的人，把目光放在全人类这个维度，不断地把自己融入到世界上，而不是把自己封闭起来，这里，你的英文语言能力对你能不能融入世界是起决定性的作用。开放自己的心态，正视自己的缺点，你才可能往前迈进。你的视野决定了你的知不知道要去哪，你的开放决定了你想不想去。 站在更高的维度。面的维度会超过点的维点，空间的维度会超过面的维度，在更高维度上思考和学习，你会获得更多。整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……），只会让你变得越来越平庸，只要你站在更高的维度（比如： 眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……），时间会让你明白那些低维度的东西全都不是事儿。技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。 精于计算得失。很多人其实不是很懂计算。绝大多数人都是在算计自己会失去多少，而不会算会得到多少。而一般的人也总是在算短期内会失去什么，优秀则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。*精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。* 勇于跳出传统的束缚。有时候，跳出传统并不是一件很容易的事，因为大多数人都会对未知有恐惧的心理。比如：我看到很多人才都被大公司垄断了，其实，有能力的人都不需要加入大公司，有能力的人是少数，这些少数的人应该是所有的公司share着用的，这样一来，对于所有的人都是利益最大化的。这样的事现在也有，比如：律师、设计师……。但是，绝大多数有能力的技术人员是不敢走出这步。我在2015年到2016年实践过一年半，有过这些实践，做“鸡”的比“二奶”好多了，收入也好很多很多（不好意思开车了）……  庄子说过几句话——
 井蛙不可以语于海者，拘于虚也；//空间局限
夏虫不可以语于冰者，笃于时也；//时间局限
曲士不可以语于道者，束于教也。//认识局限
 别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想，共勉！
————————————————————
注：这篇文章就是要劝大家更为开放，让自己有更多的可能性，能到更高的层次，做更有价值的事，成为更强更好的人……当然，如果你觉得你只想做一个平凡人，也和本文并不冲突……另外你也不要觉得这篇文章是让你要成为一个精英，但你一定要去摸高……这篇文章是告诉你一种面对人生的思考方式，在这种思考方式下，你会有更多的可能性，更大的场景……而不是直接把自己归到“平常人”，把自己“墙”了！
注：我以为用Java适合做架构这事应该是常识了，但是评论中有很多人非常反对这个事。那我解释一下吧：首先，小型的项目用什么语言都行，爱用什么用什么。但是，真正的企业级架构就不一样了，其中并不仅仅只是RESTful API或RPC，还有各种配套设施和控制系统，比如：应用网关，服务发现、配置中心、健康检查、服务监控、服务治理（熔断、限流、幂等、重试、隔离、事务补偿）、Tracing监控、SOA/ESB、CQRS、EDA……这些东西在非Java的技术栈体系内，很难看到全貌，Java强大的生态环境，就是让你把注意力放到更高层次的架构和业务上来的。（千万不要觉得，整几个服务RPC一下，加个缓存，加个队列，就能叫架构，那只是系统集成罢了）</p>
      </div>
      <div class="card-footer">
        <span class="float-left">February 1, 2021</span>
        <a
        href="/posts/do-not-wall/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/how-to-learn/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/hero-google.svg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">工程师应该如何高效学习</h5>
        <p class="card-text post-summary">此文转自曹春晖blog，也用于自己学习的一些参考
博客地址
阅读书籍 对于工程师来说，从书籍得来的知识是必不可少的。现在很多年轻的程序员会从网络博客来学习技术，但博客内容大多缺乏体系(主要说总结性质的博客内容)，不系统。很多博主为了掩饰自己的未知，遇到不知道的关键点就一笔带过，进而导致缺失。即使原作者非常努力，内容上没有缺失，你能从中获取的也只是别人总结好的知识，没有自己的主动思考，这中间便缺少过程式的沉淀，一味地满足于背诵别人总结好的知识，最后也只不过沦为他人的复读机而已。
对于工程师来说，书籍依然是最重要的知识获取媒介。即使只是通过目录概览，也能获取某个领域的大致蓝图。
目前大部分优秀的技术书籍依然以英文为主，能够读懂英文技术书籍是工程师的硬实力。英语阅读能力怎么训练呢？如果不是为了应试，可以尝试逼迫自己去翻译一些英文文档/文章来进行专门训练。举个例子，为了学习 Go，笔者曾经和社区的小伙伴合作翻译过《The Go Programming Language》，后来为了深入学习 es，参与了社区的 《es 权威指南》 的翻译和校对工作。如果某篇技术文档你从生理上很厌恶它，但是又觉得内容不得不学习的话，那你就逼迫自己去翻译它。千字以内的文档，周末抽一个下午就可以搞定。这里已经说是逼迫了，自然可以想见这个过程并不像打游戏那么轻松愉快，但只要熬过了这个阶段，阅读技术相关的英文文档可以显著提升速度。
具备一定的英语能力之后，接下来就是从什么渠道去获取内容。如果对电子书不排斥的话，目前比较经济的选择是申请一个国内的 ACM 会员，并且用该会员去注册oreily 在线书店。一年大概 20 美元，可以及时地阅读到大部分出版社的技术出版物。因为现在出版社的网站大多还支持 early preview，所以你甚至可以在书籍还没有上市之前就预先学习内容，第一时间获取整个业界的一线情报，能够帮助你站在时代的潮头。等两年后同事拿到翻译生涩的中文版的时候，你已经可以从容地 diss 他在信息源上落后了自己整整两年。(当然，如果你有兴趣，国内的出版社一般在英文新书出版的时候会招募翻译志愿者，如果你对一个领域特别感兴趣，关注出版社的这些招募消息也可以去参与。这里要指出，不要对做翻译这件事情抱太高期望，重在提升自己的能力。想赚钱的话就算了。)
如果喜欢一边阅读一边在页边写写画画，电子书还是稍微困难点，当然这个问题你也可以用 ipad pro + apple pencil 来解决。但有些人比较喜欢实体书捧在手上的实感，国外有些书甚至是个人出版物，例如笔者之前购入的《timeless law of software development》，这些书在互联网上正盗均无，只能考虑通过海淘渠道入手。前些年淘宝的海淘服务也可以用来淘书，书籍大多比较重，运费不菲。有些老书运费可能会到书费的一半让人格外肉疼。又因为国内对出版物管制比较严格，所以为了避险，这两年这些海淘服务商基本上都不帮忙代购出版物了。对于个人用户来说，也就只剩下了直邮和转运两种选择。直邮虽然比较便宜，但是万国联盟的 EMS 一走到中国可能就上了牛车，速度慢到突破极限。基本脑子稍微正常的都会选择转运。除了速度之外，有些出版社的书籍是只在美帝本土销售的，不支持 global delivery。
走转运的话，需要办一张 visa 或者 mastercard 的多币种信用卡，这样才能在海外网站进行支付 。
上面这些问题都解决了以后，书籍的获取就不再是问题。
信息源 虽然文章开头对于传统的书籍大赞特赞，但书籍的缺点也是显而易见的。在技术领域，这个缺点就尤为明显：时效问题。如果我们所学习的是相对比较老的领域知识，那只要读书基本上就够了。
但技术的发展日新月异，如果你想要成为知晓领域内所有新技术的那个人。你还是需要关注一些书籍以外的新闻源，下面是一些例子：
Github Trending Github Trending 代表的是一种风向，一般一个项目能上 trending 的话，可能是作者自己去 hacker news、reddit 做了宣传，也可能是被某个业界大佬带了流量。因为现在 Github 上的国人越来越多，很多国人学习技术比较显著的诉求其实只是面试(汗，一旦什么 xx interview/xx road to 架构师之类的仓库开了就会吸引一大批国人点星，近两年 trending 的质量有下跌趋势。
不过最近 Github Trending 增加了按照 Spoken Language 筛选功能，所以你可以过滤特定的语言，相对比之前还是好多了。</p>
      </div>
      <div class="card-footer">
        <span class="float-left">February 1, 2021</span>
        <a
        href="/posts/how-to-learn/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/programmer-career/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/hero-google.svg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">程序员如何把控自己的职业</h5>
        <p class="card-text post-summary">这篇文章摘自陈皓（左耳朵耗子）的blog（2020/08/07上传），其中很多观点击中了我内心的想法，或许可以在我遇到方向性问题的时候给我提醒。
这篇文章的主要内容主要是我今年3月份在腾讯做的直播，主要是想让一些技术人员对世界有一个大体的认识，并且在这个认识下能够有一个好的方法成就自己。而不是在一脸蒙圈的状态下随波逐流，而日益迷茫和焦虑。直播完后，腾讯方面把我的直播形成文字的形式发了出来，我觉得我可以再做一个精编版。所以，有了这篇文章，希望对大家有帮助。
对我来说，在我二十多年的工作经历来看，期间经历了很多技术的更新换代，整个技术模式、业务模式也是一直变来变去，我们这群老程序员成长中所经历的技术比今天的程序员玩的还更杂更多。我罗列一下我学过的，而且还被淘汰掉的技术，大家先感受一下。
- MIS应用开发：FoxPro，PowerBuilder，Delphi - OA：Lotus Notes，VBScripts - 微软：ODBC/ADO，COM/DCOM，MFC/ATL，J++ - 服务器：AIX，HP-UX，SCO Unix - Web：CGI，ISAPI，SOAP - RPC：CICS，Tuxedo - J2EE：Websphere，Weblogic - DB：Sybase，Informix 我想说的是，无论过去还是今天，我们这些前浪和你们后浪所面对的技术的挑战和对技术的焦虑感是相似的，我们那个时候不但玩996，还玩封闭开发（就是一周只能回家一天）。当然，唯一好的东西，就是比起今天的程序员来说，我们那个年代没有像微信、微博、知乎，抖音这些巨大消耗你人生的东西，所以，我们的工作、生活和成长都有很效率，不会被打断、喜欢看书、Google还没有被封……当然，那时代没有StackOverlow和Github这样的东西，所以，能完成的东西或质量都一般。
当然，这里并不是想做一个比较，只是想让大家了解一下两代程序员间的一些问题各有千秋，大同小异。在整个成长过程中，其实有很多东西是相通的，其本上来说，就是下面的三件事——
第一，如果想要把控技术，应对这个世界的一些变化，需要大致知道这个世界的一些规律和发展趋势，另外还得认识自己，自己到底适合做什么？在这个趋势和规律下属于自己的发挥领域到底是什么？这是我们每个人都需要了解的。
第二，打牢基础，以不变应万变，不管世界怎样变化，我都能很快适应它。基础的重要程度对于你能够飞多高是相当有影响的，懂原理的人比不懂原理的人能做出来的事情或是能解决的问题完全是两个层级的。
第三，提升成长的效率，因为现在社会的节奏实在太快了，比二十年前快得太多，技术层出不穷，所以我们的成长也要更有效率。效率并不单指的快，效率是怎么样更有效，是有用功除以总功（参看《加班与效率》），怎么学到更有效的东西，或者怎么更有效学习，是我们需要掌握的另一关键。
下面是我这多年来的一些认识，希望对你有帮助。
世界发展趋势 我个人经历的信息化革命应该分成三个阶段：
 1990年代到2000年，这个时代MB时代，是雅虎、新浪、搜狐、网易门户网站的时代，这个时代就是ISP/ICP互联网提供商，把一些资讯数字化，然后发布到网络上。 2000年到2010年，这个时代叫GB时代，或是叫多媒体或UGC时代，上网开始变得普遍了，每个人手里的数码设备开始变得多了起来，可以上传照片，可以上传视频，甚至可以在网上做社交。 2010年到2020年，这个时代叫TB时代，这过去的十年是移动互联网时代，移动互联网只需要手机在线，不需要依靠电脑。因为手机随时在线，所以个人的各种各样的数据始终在被收集，只要用户上网就会产生数据，所以人的行为最终也被数字化了。  所有的硬件和软件都是跟着需要处理的数据而演进的，我们需要更大的带宽，更大的硬盘，更多的处理器……大到一定时候就只能进入分布式化的技术架构了，再大，数据中心也顶不住了，就会要引入更为分布式的边缘计算了。
另一方面，从业务上来看，我们可以看到整个世界就在不断地进行数字化，因为，只要数字化了，就可以进行复制传播和计算，只要可以进行计算了，就可以进行数学建模，就可以自动化，只要可以自动化了就可以规模化，只要可能规模化了，就可以改变整个行业。人类的近代史的大趋势基本上都是在解决能源和自动化的事，源源不断的能源是让机器不知疲倦的前提条件，用机器代替牲口，代替人类进行工作是规模化的前提条件。
所以，技术的演进规律基本是自动化加规模化，从而降低成本，提升效率。这就是为什么世界变得越来越快，人类都快跟不上节奏的原因，主要是整个社会不断被机器、数据所驱动。
人才需求 在这个过程中，需要什么样的人？下面是我的一些认识——
 技工，在机器和自动化面前，肯定是需要能够操作机器的技术工人了，这类人是有技术的劳动力。在编程的圈子里俗称“码农”，他们并不是真正的工程师，他们只是电脑程序的操作员，所以，随着技术门槛的下降或是技术形式的变更他可能就会变得越来越不值钱，直到被淘汰掉。 特种工，这种人是必须了解原理和解决难题的一类人，他们是解决比较难的、特定的一些技术问题。当一种技术被淘汰，他并不容易被淘汰，因为他懂原理，原理就是解决问题的能力，是解决问题的套路和方法。 工程师，不但是使用技术，还可以把活儿做好，他们认为代码更多的时间是在维护，这些人使用各种各样的手段和各种技术，精益求精地持续不断地提高代码的易读性、扩展性、可维护性和重用性，这个过程似乎永无止境。对于这些有“洁癖”，有“工匠精神”，有“修养”的技术人员，我们称他们为工程师。这种人做事又稳又快，而且可以做出很多称手的工具和方法论。 再往上是设计师和架构人员，这些人主要是开发一些工具，框架，模式，提升软件开发和维护效率，同时也提升用户体验，和提升稳定性、性能、代码重用等，总的来说就是为了降本增效。这类人的工作降低了技术得到门槛，他们把技术门槛降低了以后，就可以把这个技术普及开来，就可以由广大劳工、技工、特殊工人使用了。 还有一类人是经理，经理主要是组织团队、完成项目、创造利润。这类人中，即有身先士卒的leader，也有高高在上的boss，但无论怎么样，这些人只不过是为了让一个公司或是一个团队更好组织在一起的“粘合剂”，这类人只有在大公司中才会变成更有价值。  这就是我总结的世界需要哪些人才，我们了解这些东西以后大概就明白我们现在所处的位置有什么样的问题，我们应该去什么样的地方。
Google 评分卡 接下来，我们再来看看Google的SRE的自我评分卡：
0 – 对于相关的技术领域还不熟悉 1 – 可以读懂这个领域的基础知识 2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节。 3 – 基本精通这个技术领域，完全不需要别人的帮助 4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作。 对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识。 对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。 5 – 对于该技术领域有非常底层的了解和深入的技能。 6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构 7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作。 8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施 9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法。 10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人。 SRE需要自评如下这些技术或技能。</p>
      </div>
      <div class="card-footer">
        <span class="float-left">February 1, 2021</span>
        <a
        href="/posts/programmer-career/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/websocket/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">A Million WebSocket and Go</h5>
        <p class="card-text post-summary">这篇文章是我研究高负载网络服务器架构看到的的一个有趣的story，添加了我自身学习websocket的感受和记录，希望我能在飞机落地前写完:-)
Preface 我们先描述一个问题作为讨论的中心：用户邮件的存储方法。
对于这种主题，有很多种方式在系统内对邮件状态进行持续的追踪，比如系统事件是一个方式，另一种方式可以通过定期的系统轮询有关状态变化。
这两种方式各有利弊，不过当我们讨论到邮件的时候，用户希望收到新邮件的速度越快越好。邮件轮询每秒约有50000个HTTP请求，其中60%返回304状态，也就是邮箱内没有任何修改。
因此，为了减少服务器的负载并加快向用户传递邮件的速度，我们决定通过编写publisher-subscriber服务器(即bus, message broker, event channel)来重新发明轮子。一方面接受有关状态变更的通知，另外一个方面接受此类通知的订阅。
改进前：
+--------------+ (2) +-------------+ (1) +-----------+ | | &lt;--------+ | | &lt;--------+ | | | Storage | | API | HTTP | Browser | | | +--------&gt; | | +--------&gt; | | +--------------+ (3) +-------------+ (4) +-----------+ 改进后:
+--------------+ +-------------+ WebSocket +-----------+ | Storage | | API | +----------&gt; | Browser | +--------------+ +-------------+ (3) +-----------+ + ^ | (1) | (2) v + +-----------------------------------------+ | Bus | +-----------------------------------------+ 改进前的方案也就是browser定期去查询api并访问存储更改</p>
      </div>
      <div class="card-footer">
        <span class="float-left">January 16, 2021</span>
        <a
        href="/posts/golang/websocket/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
    </div>
    <div class="paginator">
      
<ul class="pagination">
  <li class="page-item">
    <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/posts/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/posts/page/2/">2</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/posts/page/3/">3</a>
  </li>
  <li class="page-item">
    <a href="/posts/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/posts/page/3/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


    </div>
  </div>
</section>


      
       
    </div>

    

  




  




  
  
    
  


<footer class="container-fluid text-center align-content-center footer pb-2">
  <div class="container pt-5">
    <div class="row text-left">
      <div class="col-md-4 col-sm-12">
        <h5>Navigation</h5>
        
        <ul>
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#about">About</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#skills">Skills</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#experiences">Experiences</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#recent-posts">Recent Posts</a>
              </li>
            
        </ul>
        

      </div>
      
      <div class="col-md-4 col-sm-12">
        <h5>Contact me:</h5>
        <ul>
          
          <li><span>Email: </span> <span>yxhuang@g.ucla.edu</span></li>
          
          <li><span>Phone: </span> <span>&#43;86-18657825298</span></li>
          
        </ul>
      </div>
      
      
    </div>
  </div>
  <hr />
  <div class="container">
    <div class="row text-left">
      <div class="col-md-4">
        <a id="theme" href="https://github.com/hossainemruz/toha" target="#">
          <img src="/assets/images/inverted-logo.png">
          Toha
        </a>
      </div>
      <div class="col-md-4 text-center">© 2020 Copyright.</div>
      <div class="col-md-4 text-right">
        <a id="hugo" href="https://gohugo.io/">Powered by
        <img
          src="/assets/images/hugo-logo-wide.svg"
          alt="Hugo Logo"
          height="18"
        />
        </a>
      </div>
    </div>
  </div>
</footer>

    <script src="/assets/js/jquery-3.4.1.min.js"></script>
<script src="/assets/js/popper.min.js"></script>
<script src="/assets/js/bootstrap.min.js"></script>

<script src="/assets/js/navbar.js"></script>
<script src="/assets/js/main.js"></script>


    
    
    <script src="/assets/js/list.js"></script>

  </body>
</html>
