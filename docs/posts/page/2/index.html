<!DOCTYPE html>
<html>
  <head>
    <title>Posts</title>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />


<link rel="stylesheet" href="/assets/css/bootstrap.min.css"/>
<link rel="stylesheet" href="/assets/css/layouts/main.css"/>
<link rel="stylesheet" href="/assets/css/style.css"/>
<link rel="stylesheet" href="/assets/css/navigators/navbar.css"/>


<link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" />


<link rel="icon" type="image/png" href="/assets/images/favicon.png" />


<link rel="stylesheet" href="/assets/css/style.css"/>

    
    <link rel="stylesheet" href="/assets/css/layouts/list.css">
    <link rel="stylesheet" href="/assets/css/navigators/sidebar.css">


    
    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-190574896-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
  </head>

  <body data-spy="scroll" data-target="#TableOfContents" data-offset="80">
    <div class="container-fluid bg-dimmed wrapper">
      
      
    


  


  


<nav class="navbar navbar-expand-xl top-navbar final-navbar shadow">
  <div class="container">
      <button class="navbar-toggler navbar-light" id="sidebar-toggler" type="button" onclick="toggleSidebar()">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/">
      <img src="/assets/images/main-logo.png">CctoctoFX</a>
    <button class="navbar-toggler navbar-light" id="toc-toggler" type="button" onclick="toggleTOC()">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse lang-selector" id="top-nav-items">
      <ul class="navbar-nav ml-auto">
      
      </ul>
    </div>
  </div>
  
  <img src="/assets/images/main-logo.png" class="d-none" id="main-logo">
  <img src="/assets/images/inverted-logo.png" class="d-none" id="inverted-logo">
</nav>



      
      
  
  

  <section class="sidebar-section" id="sidebar-section">
    <div class="sidebar-holder">
      <div class="sidebar" id="sidebar">
        <input type="text" value="" placeholder="Search" data-search="" id="search-box" />
        <div class="sidebar-tree">
          <ul class="tree" id="tree">
            <li id="list-heading"><a href="https://pillumina.github.io/posts" data-filter="all">Posts</a></li>
            <div class="subtree">
                
  
  
  
  
  
    
    <li><a class="" href="/posts/black-magic/">Black Magic</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/iaas-paas-diff/">IaaS vs PaaS vs SaaS</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/links/">Tracking</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/do-not-wall/">别让自己墙了自己</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/how-to-learn/">工程师应该如何高效学习</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/programmer-career/">程序员如何把控自己的职业</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/algo/">FX算法笔记</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/golang/">Golang Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/golang/channels/">Channels Concurrency</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/fasthttp/">fasthttp对性能的优化研究</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/bdd-testing-framework/">Ginkgo 测试框架</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/lifecycle-of-http/">Go server中http请求的生命周期</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/go-testing/">Golang Testing Kits</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/memory-management/">Golang内存管理</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/schedualing/">Golang并发调度</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/golang-escape-analysis/">Golang逃逸分析</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/goroutine-pool/">Goroutine Pool</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/websocket/">Million WebSocket</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/go-profiling/">Profling Go Service</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/sync-pool/">Sync Pool源码分析</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/channel-graceful/">优雅关闭通道</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/memory-leak/">可能的内存泄漏场景</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/java/">Java Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/java/java-fundamentals/">Java Fundamentals</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/cloud-computing/">Kubernetes &amp; Docker</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-basic/">Docker Cheat Sheet</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-cgroup/">Docker Fundamentals (Cgroup)</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-namespace/">Docker Fundamentals (Namespace)</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/k8s-basic/">Kubernetes Handbook (Start &amp; Pod)</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/notes/">Notes</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/notes/my-first-note/">MIT distributed system courses</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/design-pattern/">Programming Pattern</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/design-pattern/">Design Pattern Overview</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/go-pipeline/">Go Pipeline Pattern</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/go-visitor/">Go Visitor Pattern (k8s)</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/python/">Python Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/python/python-functionality/">Python类自定义</a></li>
  


      </ul>
    </li>
  


            </div>
          </ul>
        </div>
      </div>
    </div>
  </section>


      
      
<section class="content-section" id="content-section">
  <div class="content container-fluid" id="content">
    <div class="container-fluid post-card-holder" id="post-card-holder">
      
      
        <div class="post-card">
  <a href="/posts/golang/websocket/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">A Million WebSocket and Go</h5>
        <p class="card-text post-summary">这篇文章是我研究高负载网络服务器架构看到的的一个有趣的story，添加了我自身学习websocket的感受和记录，希望我能在飞机落地前写完:-)
Preface 我们先描述一个问题作为讨论的中心：用户邮件的存储方法。
对于这种主题，有很多种方式在系统内对邮件状态进行持续的追踪，比如系统事件是一个方式，另一种方式可以通过定期的系统轮询有关状态变化。
这两种方式各有利弊，不过当我们讨论到邮件的时候，用户希望收到新邮件的速度越快越好。邮件轮询每秒约有50000个HTTP请求，其中60%返回304状态，也就是邮箱内没有任何修改。
因此，为了减少服务器的负载并加快向用户传递邮件的速度，我们决定通过编写publisher-subscriber服务器(即bus, message broker, event channel)来重新发明轮子。一方面接受有关状态变更的通知，另外一个方面接受此类通知的订阅。
改进前：
+--------------+ (2) +-------------+ (1) +-----------+ | | &lt;--------+ | | &lt;--------+ | | | Storage | | API | HTTP | Browser | | | +--------&gt; | | +--------&gt; | | +--------------+ (3) +-------------+ (4) +-----------+ 改进后:
+--------------+ +-------------+ WebSocket +-----------+ | Storage | | API | +----------&gt; | Browser | +--------------+ +-------------+ (3) +-----------+ + ^ | (1) | (2) v + +-----------------------------------------+ | Bus | +-----------------------------------------+ 改进前的方案也就是browser定期去查询api并访问存储更改</p>
      </div>
      <div class="card-footer">
        <span class="float-left">January 16, 2021</span>
        <a
        href="/posts/golang/websocket/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/fasthttp/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">fasthttp对性能的优化压榨</h5>
        <p class="card-text post-summary">最近在看网络模型和go net的源码，以及各web框架例如fasthttp, weaver, gnet(更轻量)源码。fasthttp在github上已经写上了一个go开发的best practices examples,这里我也记录一些在源码中看到的一些技巧
[]byte buffer的tricks 下面的一些tricks在fasthttp中被使用，自己的代码也可以用
 标准Go函数能够处理nil buffer  var ( // both buffers are uninitialized 	dst []byte src []byte ) dst = append(dst, src...) // is legal if dst is nil and/or src is nil copy(dst, src) // is legal if dst is nil and/or src is nil (string(src) == &#34;&#34;) // is true if src is nil (len(src) == 0) // is true if src is nil src = src[:0] // works like a charm with nil src  // this for loop doesn&#39;t panic if src is nil for i, ch := range src { doSomething(i, ch) } 所以可以去掉一些对[]bytebuffer的nil校验:</p>
      </div>
      <div class="card-footer">
        <span class="float-left">January 10, 2021</span>
        <a
        href="/posts/golang/fasthttp/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/sync-pool/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">[源码分析]sync pool</h5>
        <p class="card-text post-summary">- 当多个goroutine都需要创建同一个对象，如果gorountine数过多，导致对象的创建数目剧增，进而导致GC压力增大，形成“并发大-占用内存大-GC缓慢-并发处理能力弱-并发更大”这样的恶性循环 - 在这个时候，需要一个对象池，每个goroutine不再自己单独创建对象，而是从对象池中取出一个对象（如果池中已有） </p>
      </div>
      <div class="card-footer">
        <span class="float-left">January 1, 2021</span>
        <a
        href="/posts/golang/sync-pool/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/goroutine-pool/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">[自建轮]高性能Goroutine Pool</h5>
        <p class="card-text post-summary">高性能Goroutine Pool go调度器没有限制对goroutine的数量，在goroutine瞬时大规模爆发的场景下来不及复用goroutine从而导致大量goroutine被创建，会导致大量的系统资源占用，尝试池化。
go调度器本身不应该对goroutine数量有限制，因为语言层面无法界定需要限制多少，毕竟程序跑在不同性能的环境，在并发规模不太大的场景做限制甚至会降低性能，原生支持限制goroutine数量无疑是得不偿失的。如果只是中等规模和比较小规模的并发场景其实pool的性能并没有优势
目前设计上还需要加上周期性对空闲队列的prune，等写完再加看看benchmark会提升多少。目前来说对大规模goroutine异步并发的场景(1M, 10M)内存优化(10倍往上)和吞吐量优化效果(2-6倍)非常好。
需求场景与目标  限制并发goroutine的数量 复用goroutine，减轻runtime调度压力，提升程序性能 规避过多的goroutine创建侵占系统资源，cpu&amp;内存  关键技术  锁同步: golang有CAS机制，用spin-lock替代mutex 原理， 讨论 LIFO/FIFO队列: LIFO队列能直接有时间排序功能，方便对需要关联入队时间的操作进行处理 Pool容量限制和弹性伸缩  代码实现 pool.go package go_pool import ( &#34;errors&#34; &#34;sync&#34; &#34;sync/atomic&#34; &#34;time&#34; ) const( OPEN = iota CLOSED ) var ( ErrPoolClosed = errors.New(&#34;this pool has been closed&#34;) ErrPoolOverload = errors.New(&#34;too many goroutines blocked on submit or Nonblocking is set&#34;) ErrInvalidExpiryTime = errors.New(&#34;invalid expiration time&#34;) ErrInvalidPoolCapacity = errors.New(&#34;invalid pool capacity&#34;) DefaultScanInterval = time.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 30, 2020</span>
        <a
        href="/posts/golang/goroutine-pool/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/memory-leak/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Possible Memory Leak</h5>
        <p class="card-text post-summary">实际上对于一个有GC的语言，我们不必太多关心内存泄漏的问题，因为程序的runtime帮我们很好地额回收不再使用的内存。但是，我们还是得了解一些特殊的场景，这些场景会产生暂时性或者永久性的内存泄漏。
待开坑...</p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 25, 2020</span>
        <a
        href="/posts/golang/memory-leak/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/channel-graceful/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Close Channels Gracefully</h5>
        <p class="card-text post-summary">优雅地关闭通道 场景一：M个接收者和一个发送者。发送者通过关闭用来传输数据的通道来传递发送结束信号 这是最简单的一种情形。当发送者欲结束发送，让它关闭用来传输数据的通道即可。
package main import ( &#34;time&#34; &#34;math/rand&#34; &#34;sync&#34; &#34;log&#34; ) func main() { rand.Seed(time.Now().UnixNano()) log.SetFlags(0) // ... 	const Max = 100000 const NumReceivers = 100 wgReceivers := sync.WaitGroup{} wgReceivers.Add(NumReceivers) // ... 	dataCh := make(chan int) // 发送者 	go func() { for { if value := rand.Intn(Max); value == 0 { // 此唯一的发送者可以安全地关闭此数据通道。 	close(dataCh) return } else { dataCh &lt;- value } } }() // 接收者 	for i := 0; i &lt; NumReceivers; i++ { go func() { defer wgReceivers.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 24, 2020</span>
        <a
        href="/posts/golang/channel-graceful/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/channels/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Channels Concurrency Work-Around</h5>
        <p class="card-text post-summary">记录了一些channels常见的场景，以及自己的一些感受：
  使用通道进行异步和并发编程是简单和惬意的；
  通道同步技术比被很多其它语言采用的其它同步方案（比如角色模型和async/await模式）有着更多的应用场景和更多的使用变种。
通道作为同步手段，并非在任何情况下都是最佳的同步技术，本文也会补充原子操作和sync包内其他的技术作为参考。
  将通道用做future/promise 很多其它流行语言支持future/promise来实现异步（并发）编程。 Future/promise常常用在请求/回应场合。
返回单向接收通道做为函数返回结果 在下面这个例子中，sumSquares函数调用的两个实参请求并发进行。 每个通道读取操作将阻塞到请求返回结果为止。 两个实参总共需要大约3秒钟（而不是6秒钟）准备完毕（以较慢的一个为准）。
package main import ( &#34;time&#34; &#34;math/rand&#34; &#34;fmt&#34; ) func longTimeRequest() &lt;-chan int32 { r := make(chan int32) go func() { time.Sleep(time.Second * 3) // 模拟一个工作负载 	r &lt;- rand.Int31n(100) }() return r } func sumSquares(a, b int32) int32 { return a*a + b*b } func main() { rand.Seed(time.Now().UnixNano()) a, b := longTimeRequest(), longTimeRequest() fmt.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 22, 2020</span>
        <a
        href="/posts/golang/channels/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/black-magic/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/hero-google.svg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Black Magic</h5>
        <p class="card-text post-summary">阅读到的一些方便、有趣的技巧或者ideas的随手记录，后续考虑对相关话题专门开坑
一行代码画出专业的论文图 SciencePlots
计算机专业向来不缺少专业的绘图软件，从Excel到PPT，从最近沸沸扬扬的Matlab到Matplotlib、pyplot、ggplot，乃至其他更为专业的软件，着实丰富了我们的画图生活。
但是，这些软件或工具的背后，常常需要我们付出更多的努力：调色、统一格式、展示要高大上，等等。
现在，一款开源的软件工具包问世了：SciencePlots。它让你用一行代码画出天然高端且美观的论文图。
SciencePlots是一个依附于Matplotlib的扩展包，可以通过pip一键安装：
pip install SciencePlots 然后我们在画图时，只需要一句with.plt.style.context(['science']):，就可以画出非常美观且专业的图：
你还可以加一个选项with.plt.style.context(['science','ieee']):，就能画出IEEE格式的图：
甚至是超美的散点图：
还有很多自定义的图像风格，保证节约我们的画图时间
 这个包默认会调用latex来画图，如果不想用latex（也不是完全需要），可以在context里写一个属性&rsquo;nolatex&rsquo;即可。不然如果没有安装latex或latex路径配置有问题，则会报错。
 </p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 20, 2020</span>
        <a
        href="/posts/black-magic/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/links/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/hero-google.svg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Tracking</h5>
        <p class="card-text post-summary">这个post为记录目前正在阅读与研究的section
Go语言设计 Go语言设计与实现
Go Under The Hood
这两本在写作目的和内容规划都是一致的，不过第二个原本不再维护内容，作者开了下面的新的项目，把撰写原本而积累的与Go相关的资源进行了重新的整理。 Go设计历史
pprof对服务端性能影响的研究 考虑一些极端场景，比如极度追求性能，压榨系统资源以及技术栈必须是Go的业务场景下，是否能自己构建Reactor网络模型
GRPC框架对服务侧性能的影响 Russ Cox正则表达式系列 You should not be permitted to write production code if you do not have an journeyman license in regular expressions or floating point math. &ndash; Rob Pike
Regular Expression Matching Can Be Simple And Fast
编译器词法分析:正则语言和正则表达式
Go内存原理与调度模型 正在整理专栏
Bound Checking Elimination Crafting Interpreter 时常看PL和Compiler的基础
crafting interpreters
Kosaraju&rsquo;s Algorithm 看William Lin的coding interview觉得用来处理树和图很好，算法4里也有
Heilmeier问题系列 思考某篇paper的选题
 What are you trying to do?</p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 19, 2020</span>
        <a
        href="/posts/links/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/go-testing/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Golang TDD</h5>
        <p class="card-text post-summary">Preface 本文整理golang编码的单元测试常用示例，以及TDD的简要流程。
单元测试基础 单元测试文件以_test.go结尾，需要记住以下原则：
 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 你必须import testing这个包 所有的测试用例函数必须是Test开头 测试用例会按照源代码中写的顺序依次执行 测试函数TestXxx()的参数是testing.T，我们可以使用该类型来记录错误或者是测试状态 测试格式：func TestXxx (t *testing.T),Xxx部分可以为任意的字母数字的组合，但是首字母不能是小写字母[a-z]，例如Testintdiv是错误的函数名。 函数中通过调用testing.T的Error, Errorf, FailNow, Fatal, FatalIf方法，说明测试不通过，调用Log方法用来记录测试的信息。  Table-Driven-Testing 测试讲究 case 覆盖，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。
func TestFib(t *testing.T) { var fibTests = []struct { in int // input  expected int // expected result  }{ {1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 5}, {6, 8}, {7, 13}, } for _, tt := range fibTests { actual := Fib(tt.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 19, 2020</span>
        <a
        href="/posts/golang/go-testing/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/golang/schedualing/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/golang2.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Golang并发调度</h5>
        <p class="card-text post-summary">性能提升不会凭空出现，它总是伴随着代码复杂度的上升。 The performance improvement does not materialize from the air, it comes with code complexity increase.
&ndash; Dmitry Vyukov
Go 语言的调度器我认为应该是整个运行时最有趣的组件了。对于Go本身，它的设计和实现直接牵动了Go运行时的其他组件，也是和用户态代码直接打交道的部分；对于Go用户而言，调度器将其极为复杂的运行机制隐藏在了简单的关键字go下。为了保证高性能，调度器必须有效得利用计算的并行性和局部性原理；为了保证用户态的简洁，调度器必须高效得对调度用户态不可见的网络轮训器、垃圾回收器进行调度；为了保证代码执行的正确性，必须严格实现用户态代码的内存顺序等。总而言之，调度器的设计直接决定了Go运行时源码的表现形式。
设计原理 数据结构: MPG 调度器启动 创建Goroutine 调度循环 触发调度 线程管理 总结 </p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 17, 2020</span>
        <a
        href="/posts/golang/schedualing/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/python/python-functionality/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/python-coder.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Python类自定义</h5>
        <p class="card-text post-summary">python类关键字 __init__ vs __new__ __init__为初始化方法，__new__为真正的构造函数。
描述符Descriptor __contains__ __slots__ 定制类 type() python作为动态语言，和静态语言最大的不同，即函数和类的定义，不是编译的时候创建的而是动态创建的。我们常见的对类的定义:
class Hello(object): def hello(self, name=&#39;world&#39;): print(&#39;Hello, %s.&#39; % name) &gt;&gt;&gt; from hello import Hello &gt;&gt;&gt; h = Hello() &gt;&gt;&gt; h.hello() Hello, world. &gt;&gt;&gt; print(type(Hello)) &lt;class 'type'&gt; &gt;&gt;&gt; print(type(h)) &lt;class 'hello.Hello'&gt; type()函数可以查看一类类型或者变量的类型，Hello是一个class， 它的类型是个type，而h是一个instance, 它的类型就是class Hello。
同时有一个概念，就是type()不仅可以返回对象的类型，还可以创建出新的类型。我们可以不用定义class Hello() ...而动态创建出Hello类。
&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数 ... print('Hello, %s.' % name) ... &gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class &gt;&gt;&gt; h = Hello() &gt;&gt;&gt; h.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 14, 2020</span>
        <a
        href="/posts/python/python-functionality/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
    </div>
    <div class="paginator">
      
<ul class="pagination">
  <li class="page-item">
    <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/posts/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/posts/">1</a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/posts/page/2/">2</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/posts/page/3/">3</a>
  </li>
  <li class="page-item">
    <a href="/posts/page/3/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/posts/page/3/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


    </div>
  </div>
</section>


      
       
    </div>

    

  




  




  
  
    
  


<footer class="container-fluid text-center align-content-center footer pb-2">
  <div class="container pt-5">
    <div class="row text-left">
      <div class="col-md-4 col-sm-12">
        <h5>Navigation</h5>
        
        <ul>
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#about">About</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#skills">Skills</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#experiences">Experiences</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#recent-posts">Recent Posts</a>
              </li>
            
        </ul>
        

      </div>
      
      <div class="col-md-4 col-sm-12">
        <h5>Contact me:</h5>
        <ul>
          
          <li><span>Email: </span> <span>yxhuang@g.ucla.edu</span></li>
          
          <li><span>Phone: </span> <span>&#43;86-18657825298</span></li>
          
        </ul>
      </div>
      
      
    </div>
  </div>
  <hr />
  <div class="container">
    <div class="row text-left">
      <div class="col-md-4">
        <a id="theme" href="https://github.com/hossainemruz/toha" target="#">
          <img src="/assets/images/inverted-logo.png">
          Toha
        </a>
      </div>
      <div class="col-md-4 text-center">© 2020 Copyright.</div>
      <div class="col-md-4 text-right">
        <a id="hugo" href="https://gohugo.io/">Powered by
        <img
          src="/assets/images/hugo-logo-wide.svg"
          alt="Hugo Logo"
          height="18"
        />
        </a>
      </div>
    </div>
  </div>
</footer>

    <script src="/assets/js/jquery-3.4.1.min.js"></script>
<script src="/assets/js/popper.min.js"></script>
<script src="/assets/js/bootstrap.min.js"></script>

<script src="/assets/js/navbar.js"></script>
<script src="/assets/js/main.js"></script>


    
    
    <script src="/assets/js/list.js"></script>

  </body>
</html>
