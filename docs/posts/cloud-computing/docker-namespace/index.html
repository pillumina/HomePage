<!DOCTYPE html>
<html>
  <head>
    <title>Docker Fundamentals: Namespace</title>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />


<link rel="stylesheet" href="/assets/css/bootstrap.min.css"/>
<link rel="stylesheet" href="/assets/css/layouts/main.css"/>
<link rel="stylesheet" href="/assets/css/style.css"/>
<link rel="stylesheet" href="/assets/css/navigators/navbar.css"/>


<link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" />


<link rel="icon" type="image/png" href="/assets/images/favicon.png" />


<link rel="stylesheet" href="/assets/css/style.css"/>

    
<meta name="description" content="Docker Fundamentals: Namespace" />
<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css"
/>
<link rel="stylesheet" href="/assets/css/layouts/single.css"/>
<link rel="stylesheet" href="/assets/css/navigators/sidebar.css">


    
    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-190574896-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
  </head>

  <body data-spy="scroll" data-target="#TableOfContents" data-offset="80">
    <div class="container-fluid bg-dimmed wrapper">
      
      
    


  


  


<nav class="navbar navbar-expand-xl top-navbar final-navbar shadow">
  <div class="container">
      <button class="navbar-toggler navbar-light" id="sidebar-toggler" type="button" onclick="toggleSidebar()">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/">
      <img src="/assets/images/main-logo.png">CctoctoFX</a>
    <button class="navbar-toggler navbar-light" id="toc-toggler" type="button" onclick="toggleTOC()">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse lang-selector" id="top-nav-items">
      <ul class="navbar-nav ml-auto">
      
      </ul>
    </div>
  </div>
  
  <img src="/assets/images/main-logo.png" class="d-none" id="main-logo">
  <img src="/assets/images/inverted-logo.png" class="d-none" id="inverted-logo">
</nav>



      
      
  <section class="sidebar-section" id="sidebar-section">
    <div class="sidebar-holder">
      <div class="sidebar" id="sidebar">
        <input type="text" value="" placeholder="Search" data-search="" id="search-box" />
        <div class="sidebar-tree">
          <ul class="tree" id="tree">
            <li id="list-heading"><a href="https://pillumina.github.io/posts" data-filter="all">Posts</a></li>
            <div class="subtree">
                
  
  
  
  
  
    
    <li><a class="" href="/posts/black-magic/">Black Magic</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/iaas-paas-diff/">IaaS vs PaaS vs SaaS</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/links/">Tracking</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/do-not-wall/">别让自己墙了自己</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/how-to-learn/">工程师应该如何高效学习</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/programmer-career/">程序员如何把控自己的职业</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/algo/">FX算法笔记</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/golang/">Golang Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/golang/channels/">Channels Concurrency</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/fasthttp/">fasthttp对性能的优化研究</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/bdd-testing-framework/">Ginkgo 测试框架</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/lifecycle-of-http/">Go server中http请求的生命周期</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/go-testing/">Golang Testing Kits</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/memory-management/">Golang内存管理</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/schedualing/">Golang并发调度</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/golang-escape-analysis/">Golang逃逸分析</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/goroutine-pool/">Goroutine Pool</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/websocket/">Million WebSocket</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/go-profiling/">Profling Go Service</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/sync-pool/">Sync Pool源码分析</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/channel-graceful/">优雅关闭通道</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/memory-leak/">可能的内存泄漏场景</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/java/">Java Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/java/java-fundamentals/">Java Fundamentals</a></li>
  


      </ul>
    </li>
  

  
  
  
  
    
    
  
  
    
    <li>
      <i class="fas fa-minus-circle"></i><a class="active" href="/posts/cloud-computing/">Kubernetes &amp; Docker</a>
      
      <ul class="active">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-basic/">Docker Cheat Sheet</a></li>
  

  
  
  
  
    
    
  
  
    
    <li><a class="active" href="/posts/cloud-computing/docker-namespace/">Docker Fundamentals (Namespace)</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/k8s-basic/">Kubernetes Handbook (Start &amp; Pod)</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/notes/">Notes</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/notes/my-first-note/">MIT distributed system courses</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/design-pattern/">Programming Pattern</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/design-pattern/">Design Pattern Overview</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/go-pipeline/">Go Pipeline Pattern</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/go-visitor/">Go Visitor Pattern (k8s)</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/python/">Python Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/python/python-functionality/">Python类自定义</a></li>
  


      </ul>
    </li>
  


            </div>
          </ul>
        </div>
      </div>
    </div>
  </section>


      
      
<section class="content-section" id="content-section">
  <div class="content">
    <div class="container p-0 read-area">
      
      <div class="hero-area col-sm-12" id="hero-area" style='background-image: url(https://pillumina.github.io/images/posts/k8s-docker.jpg);'>
      </div>

      
      <div class="page-content">
        <div class="author-profile ml-auto align-self-lg-center">
          <img class="rounded-circle" src='/images/photo.jpeg'/>
          <h5 class="author-name"></h5>
          <p>April 1, 2021</p>
        </div>

        <div class="title">
          <h1>Docker Fundamentals: Namespace</h1>
        </div>

        <div class="post-content" id="post-content">
          <p>容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。</p>
<p>有时候我认为自己的阅读比较碎片化(<del>short-term memory越来越少</del>)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。</p>
<h2 id="什么是namespace">什么是Namespace</h2>
<p>简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。</p>
<p>这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。</p>
<p>Linux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">系统调用参数</th>
<th style="text-align:left">相关内核版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Mount namespaces</strong></td>
<td style="text-align:left">CLONE_NEWNS</td>
<td style="text-align:left"><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux 2.4.19</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>UTS namespaces</strong></td>
<td style="text-align:left">CLONE_NEWUTS</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>IPC namespaces</strong></td>
<td style="text-align:left">CLONE_NEWIPC</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>PID namespaces</strong></td>
<td style="text-align:left">CLONE_NEWPID</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>Network namespaces</strong></td>
<td style="text-align:left">CLONE_NEWNET</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>User namespaces</strong></td>
<td style="text-align:left">CLONE_NEWUSER</td>
<td style="text-align:left"><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于 Linux 3.8)</a></td>
</tr>
</tbody>
</table>
<p>其主要涉及到三个系统调用：</p>
<ol>
<li><code>clone()</code>： 实现线程的系统调用，用来创建新的线程，并可通过涉及上述参数做到隔离</li>
<li><code>unshare()</code>： 让某一个线程脱离某namespace</li>
<li><code>setns()</code>: 把某一个线程加到某namespace</li>
</ol>
<p>如果读者你想看具体的实例，请自己man一下(关注一下自己的linux虚拟机内核)，或者google一下，我这里贴一个<code>clone()</code>的source code：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _GNU_SOURCE
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/wait.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;signal.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">/* 定义一个给 clone 用的栈，栈大小1M */</span>
<span style="color:#75715e">#define STACK_SIZE (1024 * 1024)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> container_stack[STACK_SIZE];
<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> container_args[] <span style="color:#f92672">=</span> {
    <span style="color:#e6db74">&#34;/bin/bash&#34;</span>,
    NULL
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">container_main</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg)
{
    printf(<span style="color:#e6db74">&#34;Container - inside the container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#75715e">/* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span>
    execv(container_args[<span style="color:#ae81ff">0</span>], container_args); 
    printf(<span style="color:#e6db74">&#34;Something&#39;s wrong!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    printf(<span style="color:#e6db74">&#34;Parent - start a container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#75715e">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span>
    <span style="color:#66d9ef">int</span> container_pid <span style="color:#f92672">=</span> clone(container_main, container_stack<span style="color:#f92672">+</span>STACK_SIZE, SIGCHLD, NULL);
    <span style="color:#75715e">/* 等待子进程结束 */</span>
    waitpid(container_pid, NULL, <span style="color:#ae81ff">0</span>);
    printf(<span style="color:#e6db74">&#34;Parent - container stopped!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>上面的程序注释写的比较明白，和pthreads差不多。不过这个程序里，父子进程的进程空间没有什么区别，父进程能访问到的明显子进程也能访问。</p>
<p>我们用几个例子来看看linux的namespace到底是啥样的，运行的虚拟机为<code>ubuntu14.4</code></p>
<h2 id="uts-namespace">UTS Namespace</h2>
<p>这里略去一些头文件和数据结构的定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">container_main</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg)
{
    printf(<span style="color:#e6db74">&#34;Container - inside the container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    sethostname(<span style="color:#e6db74">&#34;container&#34;</span>,<span style="color:#ae81ff">10</span>); <span style="color:#75715e">/* 设置hostname */</span>
    execv(container_args[<span style="color:#ae81ff">0</span>], container_args);
    printf(<span style="color:#e6db74">&#34;Something&#39;s wrong!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    printf(<span style="color:#e6db74">&#34;Parent - start a container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">int</span> container_pid <span style="color:#f92672">=</span> clone(container_main, container_stack<span style="color:#f92672">+</span>STACK_SIZE, 
            CLONE_NEWUTS <span style="color:#f92672">|</span> SIGCHLD, NULL); <span style="color:#75715e">/*启用CLONE_NEWUTS Namespace隔离 */</span>
    waitpid(container_pid, NULL, <span style="color:#ae81ff">0</span>);
    printf(<span style="color:#e6db74">&#34;Parent - container stopped!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><code>执行上述的c++程序，会发现子进程的hostname变为了container</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ./uts
Parent - start a container!
Container - inside the container!
root@container:~# hostname
container
root@container:~# uname -n
container
</code></pre></div><h2 id="ipc-namespace">IPC Namespace</h2>
<p>IPC(Inter-Process Communication)，是Unix/Linux下的一种通信方式。IPC有共享内存、信号量、消息队列等方法。所以如果要隔离我们也要把IPC进行隔离。换句话说，这样可以保证只有在同一个namespace下的进程之间才能互相通信。目前我对IPC的原理没什么研究，查了查资料，IPC需要有个全局的ID，那么如果我们要做隔离，namespace肯定需要对这个全局ID进行隔离，不能和其他namespace中的进程共享。</p>
<p>要启动IPC隔离，我们需要在<code>clone</code>时加上<code>CLONE_NEWPIC</code>的参数:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> container_pid <span style="color:#f92672">=</span> clone(container_main, container_stack<span style="color:#f92672">+</span>STACK_SIZE, 
            CLONE_NEWUTS <span style="color:#f92672">|</span> CLONE_NEWIPC <span style="color:#f92672">|</span> SIGCHLD, NULL);
</code></pre></div><p>我们先创建一个IPC的queue，下面的全局ID为0：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ ipcmk -Q 
Message queue id: <span style="color:#ae81ff">0</span>
derios@ubuntu:~$ ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 <span style="color:#ae81ff">0</span>          hchen      <span style="color:#ae81ff">644</span>        <span style="color:#ae81ff">0</span>            <span style="color:#ae81ff">0</span>
</code></pre></div><p>如果我们不加<code>CLONE_NEWIPC</code>参数运行程序，我们可以看到在子进程中还是能看到全局的IPC queue：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ./uts 
Parent - start a container!
Container - inside the container!
root@container:~# ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 <span style="color:#ae81ff">0</span>          hchen      <span style="color:#ae81ff">644</span>        <span style="color:#ae81ff">0</span>            <span style="color:#ae81ff">0</span>
</code></pre></div><p>如果我们运行加上了<code>CLONE_NEWIPC</code>的程序，可以有如下的结果:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@ubuntu:~$ sudo./ipc
Parent - start a container!
Container - inside the container!
root@container:~/linux_namespace# ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
</code></pre></div><p>可见IPC已经被隔离。</p>
<h2 id="pid-namespace">PID Namespace</h2>
<p>我们继续修改上述的程序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">container_main</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg)
{
    <span style="color:#75715e">/* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */</span>
    printf(<span style="color:#e6db74">&#34;Container [%5d] - inside the container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());
    sethostname(<span style="color:#e6db74">&#34;container&#34;</span>,<span style="color:#ae81ff">10</span>);
    execv(container_args[<span style="color:#ae81ff">0</span>], container_args);
    printf(<span style="color:#e6db74">&#34;Something&#39;s wrong!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    printf(<span style="color:#e6db74">&#34;Parent [%5d] - start a container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());
    <span style="color:#75715e">/*启用PID namespace - CLONE_NEWPID*/</span>
    <span style="color:#66d9ef">int</span> container_pid <span style="color:#f92672">=</span> clone(container_main, container_stack<span style="color:#f92672">+</span>STACK_SIZE, 
            CLONE_NEWUTS <span style="color:#f92672">|</span> CLONE_NEWPID <span style="color:#f92672">|</span> SIGCHLD, NULL); 
    waitpid(container_pid, NULL, <span style="color:#ae81ff">0</span>);
    printf(<span style="color:#e6db74">&#34;Parent - container stopped!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>运行看一下，发现子进程的PID为1：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ./pid
Parent <span style="color:#f92672">[</span> 3474<span style="color:#f92672">]</span> - start a container!
Container <span style="color:#f92672">[</span> 1<span style="color:#f92672">]</span> - inside the container!
root@container:~# echo $$
<span style="color:#ae81ff">1</span>
</code></pre></div><p>这里的1有啥意义，你可能会问。其实在传统UNIX系统中，PID为1的进程地位比较特殊，指代<code>init</code></p>
<p>，作为所有进程的父进程，有非常多的特权（信号屏蔽etc.），此外它还会检查所有进程的状态，而且如果子进程脱离了父进程（父进程没有wait它），那么<code>init</code>会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建pid为1的进程，比如可以像chroot一样，把子进程的pid在容器内变为1。</p>
<p>不过，很奇怪的是，**我们在子进程的shell里执行top, ps等命令，还是可以看到所有的进程。**这意味着隔离并没有完全。因为像ps, top这些命令会读取<code>/proc</code>文件系统，而因为<code>/proc</code>文件系统在父子进程里都是一样的，所以命令的回显也都是一样的。</p>
<p>因此，我们还要做到<strong>对文件系统的隔离</strong>。</p>
<h2 id="mount-namespace">Mount Namespace</h2>
<p>下面的程序，我们在启用mount namespace并在子进程中重新mount了<code>/proc</code>文件系统。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">container_main</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg)
{
    printf(<span style="color:#e6db74">&#34;Container [%5d] - inside the container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());
    sethostname(<span style="color:#e6db74">&#34;container&#34;</span>,<span style="color:#ae81ff">10</span>);
    <span style="color:#75715e">/* 重新mount proc文件系统到 /proc下 */</span>
    system(<span style="color:#e6db74">&#34;mount -t proc proc /proc&#34;</span>);
    execv(container_args[<span style="color:#ae81ff">0</span>], container_args);
    printf(<span style="color:#e6db74">&#34;Something&#39;s wrong!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    printf(<span style="color:#e6db74">&#34;Parent [%5d] - start a container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());
    <span style="color:#75715e">/* 启用Mount Namespace - 增加CLONE_NEWNS参数 */</span>
    <span style="color:#66d9ef">int</span> container_pid <span style="color:#f92672">=</span> clone(container_main, container_stack<span style="color:#f92672">+</span>STACK_SIZE, 
            CLONE_NEWUTS <span style="color:#f92672">|</span> CLONE_NEWPID <span style="color:#f92672">|</span> CLONE_NEWNS <span style="color:#f92672">|</span> SIGCHLD, NULL);
    waitpid(container_pid, NULL, <span style="color:#ae81ff">0</span>);
    printf(<span style="color:#e6db74">&#34;Parent - container stopped!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>执行结果如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derioshen@ubuntu:~$ sudo ./pid.mnt
Parent <span style="color:#f92672">[</span> 3502<span style="color:#f92672">]</span> - start a container!
Container <span style="color:#f92672">[</span>    1<span style="color:#f92672">]</span> - inside the container!
root@container:~# ps -elf 
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
<span style="color:#ae81ff">4</span> S root         <span style="color:#ae81ff">1</span>     <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>   <span style="color:#ae81ff">0</span> -  <span style="color:#ae81ff">6917</span> wait   19:55 pts/2    00:00:00 /bin/bash
<span style="color:#ae81ff">0</span> R root        <span style="color:#ae81ff">14</span>     <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>   <span style="color:#ae81ff">0</span> -  <span style="color:#ae81ff">5671</span> -      19:56 pts/2    00:00:00 ps -elf
</code></pre></div><p>我们看到只有2个进程了，<code>pid=1</code>的是我们的<code>/bin/bash</code>，同时再看看<code>/proc</code>目录，也变得比较干净:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@container:~# ls /proc
<span style="color:#ae81ff">1</span>          dma          key-users   net            sysvipc
<span style="color:#ae81ff">16</span>         driver       kmsg        pagetypeinfo   timer_list
acpi       execdomains  kpagecount  partitions     timer_stats
asound     fb           kpageflags  sched_debug    tty
buddyinfo  filesystems  loadavg     schedstat      uptime
bus        fs           locks       scsi           version
cgroups    interrupts   mdstat      self           version_signature
cmdline    iomem        meminfo     slabinfo       vmallocinfo
consoles   ioports      misc        softirqs       vmstat
cpuinfo    irq          modules     stat           zoneinfo
crypto     kallsyms     mounts      swaps
devices    kcore        mpt         sys
diskstats  keys         mtrr        sysrq-trigger
</code></pre></div><p>通过<code>CLONE_NEWNS</code>创建mount namespace以后，父进程会把自己的文件结构复制给子进程。而子进程中新的namespace中所有mount操作都只会影响自身的文件系统，不会对外界产生任何影响，这就做到了严格的隔离。</p>
<p>那么我们是不是还有别的一些文件系统也要mount？答案是肯定的。</p>
<h2 id="docker的mount-namespace">Docker的Mount Namespace</h2>
<p>我们可以简单搞个小的镜像，这种玩法是我google参考来的，模仿docker的mount namespace。</p>
<p>首先，我们需要一个rootfs， 也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs$ ls
bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var
</code></pre></div><p>然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs$ ls ./bin ./usr/bin
 
./bin:
bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty
cat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount
chgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname
chmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which

./usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</code></pre></div><p>注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs/bin$ ldd bash
  linux-vdso.so.1 <span style="color:#f92672">=</span>&gt;  <span style="color:#f92672">(</span>0x00007fffd33fc000<span style="color:#f92672">)</span>
  libtinfo.so.5 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 <span style="color:#f92672">(</span>0x00007f4bd42c2000<span style="color:#f92672">)</span>
  libdl.so.2 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libdl.so.2 <span style="color:#f92672">(</span>0x00007f4bd40be000<span style="color:#f92672">)</span>
  libc.so.6 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span style="color:#f92672">(</span>0x00007f4bd3cf8000<span style="color:#f92672">)</span>
  /lib64/ld-linux-x86-64.so.2 <span style="color:#f92672">(</span>0x00007f4bd4504000<span style="color:#f92672">)</span>
</code></pre></div><p>下面是我的rootfs中的一些so文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/

./lib64:
ld-linux-x86-64.so.2

./lib/x86_64-linux-gnu/:
libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1
libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0
libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so
libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2
libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1
libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5
libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9
libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so
libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1
libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1
libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1
libdl.so.2       libnss_compat.so.2     libpthread.so.0
libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1
libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0
</code></pre></div><p>包括这些命令依赖的一些配置文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~/rootfs$ ls ./etc
bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  
resolv.conf  shadow
</code></pre></div><p>看到现在你可能比较懵逼，有的比较熟悉os的同学也可能会问：有的配置希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。OK, 那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ ls ./conf
hostname     hosts     resolv.conf
</code></pre></div><p>这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。</p>
<p>接下来是程序(<del>Google真好</del>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _GNU_SOURCE
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys types.h=&#34;&#34;&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys wait.h=&#34;&#34;&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys mount.h=&#34;&#34;&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;signal.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define STACK_SIZE (1024 * 1024)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> container_stack[STACK_SIZE];
<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> container_args[] <span style="color:#f92672">=</span> {
    <span style="color:#e6db74">&#34;/bin/bash&#34;</span>,
    <span style="color:#e6db74">&#34;-l&#34;</span>,
    NULL
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">container_main</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> arg)
{
    printf(<span style="color:#e6db74">&#34;Container [%5d] - inside the container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());

    <span style="color:#75715e">//set hostname
</span><span style="color:#75715e"></span>    sethostname(<span style="color:#e6db74">&#34;container&#34;</span>,<span style="color:#ae81ff">10</span>);

    <span style="color:#75715e">//remount &#34;/proc&#34; to make sure the &#34;top&#34; and &#34;ps&#34; show container&#39;s information
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (mount(<span style="color:#e6db74">&#34;proc&#34;</span>, <span style="color:#e6db74">&#34;rootfs/proc&#34;</span>, <span style="color:#e6db74">&#34;proc&#34;</span>, <span style="color:#ae81ff">0</span>, NULL) <span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span> ) {
        perror(<span style="color:#e6db74">&#34;proc&#34;</span>);
    }
    <span style="color:#66d9ef">if</span> (mount(<span style="color:#e6db74">&#34;sysfs&#34;</span>, <span style="color:#e6db74">&#34;rootfs/sys&#34;</span>, <span style="color:#e6db74">&#34;sysfs&#34;</span>, <span style="color:#ae81ff">0</span>, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;sys&#34;</span>);
    }
    <span style="color:#66d9ef">if</span> (mount(<span style="color:#e6db74">&#34;none&#34;</span>, <span style="color:#e6db74">&#34;rootfs/tmp&#34;</span>, <span style="color:#e6db74">&#34;tmpfs&#34;</span>, <span style="color:#ae81ff">0</span>, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;tmp&#34;</span>);
    }
    <span style="color:#66d9ef">if</span> (mount(<span style="color:#e6db74">&#34;udev&#34;</span>, <span style="color:#e6db74">&#34;rootfs/dev&#34;</span>, <span style="color:#e6db74">&#34;devtmpfs&#34;</span>, <span style="color:#ae81ff">0</span>, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;dev&#34;</span>);
    }
    <span style="color:#66d9ef">if</span> (mount(<span style="color:#e6db74">&#34;devpts&#34;</span>, <span style="color:#e6db74">&#34;rootfs/dev/pts&#34;</span>, <span style="color:#e6db74">&#34;devpts&#34;</span>, <span style="color:#ae81ff">0</span>, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;dev/pts&#34;</span>);
    }
    <span style="color:#66d9ef">if</span> (mount(<span style="color:#e6db74">&#34;shm&#34;</span>, <span style="color:#e6db74">&#34;rootfs/dev/shm&#34;</span>, <span style="color:#e6db74">&#34;tmpfs&#34;</span>, <span style="color:#ae81ff">0</span>, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;dev/shm&#34;</span>);
    }
    <span style="color:#66d9ef">if</span> (mount(<span style="color:#e6db74">&#34;tmpfs&#34;</span>, <span style="color:#e6db74">&#34;rootfs/run&#34;</span>, <span style="color:#e6db74">&#34;tmpfs&#34;</span>, <span style="color:#ae81ff">0</span>, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;run&#34;</span>);
    }
    <span style="color:#75715e">/* 
</span><span style="color:#75715e">     * 模仿Docker的从外向容器里mount相关的配置文件 
</span><span style="color:#75715e">     * 你可以查看：/var/lib/docker/containers/&lt;container_id&gt;/目录，
</span><span style="color:#75715e">     * 你会看到docker的这些文件的。
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">if</span> (mount(<span style="color:#e6db74">&#34;conf/hosts&#34;</span>, <span style="color:#e6db74">&#34;rootfs/etc/hosts&#34;</span>, <span style="color:#e6db74">&#34;none&#34;</span>, MS_BIND, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span>
          mount(<span style="color:#e6db74">&#34;conf/hostname&#34;</span>, <span style="color:#e6db74">&#34;rootfs/etc/hostname&#34;</span>, <span style="color:#e6db74">&#34;none&#34;</span>, MS_BIND, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span>
          mount(<span style="color:#e6db74">&#34;conf/resolv.conf&#34;</span>, <span style="color:#e6db74">&#34;rootfs/etc/resolv.conf&#34;</span>, <span style="color:#e6db74">&#34;none&#34;</span>, MS_BIND, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span> ) {
        perror(<span style="color:#e6db74">&#34;conf&#34;</span>);
    }
    <span style="color:#75715e">/* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */</span>
    <span style="color:#66d9ef">if</span> (mount(<span style="color:#e6db74">&#34;/tmp/t1&#34;</span>, <span style="color:#e6db74">&#34;rootfs/mnt&#34;</span>, <span style="color:#e6db74">&#34;none&#34;</span>, MS_BIND, NULL)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;mnt&#34;</span>);
    }

    <span style="color:#75715e">/* chroot 隔离目录 */</span>
    <span style="color:#66d9ef">if</span> ( chdir(<span style="color:#e6db74">&#34;./rootfs&#34;</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> chroot(<span style="color:#e6db74">&#34;./&#34;</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> ){
        perror(<span style="color:#e6db74">&#34;chdir/chroot&#34;</span>);
    }

    execv(container_args[<span style="color:#ae81ff">0</span>], container_args);
    perror(<span style="color:#e6db74">&#34;exec&#34;</span>);
    printf(<span style="color:#e6db74">&#34;Something&#39;s wrong!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    printf(<span style="color:#e6db74">&#34;Parent [%5d] - start a container!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getpid());
    <span style="color:#66d9ef">int</span> container_pid <span style="color:#f92672">=</span> clone(container_main, container_stack<span style="color:#f92672">+</span>STACK_SIZE, 
            CLONE_NEWUTS <span style="color:#f92672">|</span> CLONE_NEWIPC <span style="color:#f92672">|</span> CLONE_NEWPID <span style="color:#f92672">|</span> CLONE_NEWNS <span style="color:#f92672">|</span> SIGCHLD, NULL);
    waitpid(container_pid, NULL, <span style="color:#ae81ff">0</span>);
    printf(<span style="color:#e6db74">&#34;Parent - container stopped!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#f92672">&lt;/</span>container_id<span style="color:#f92672">&gt;&lt;/</span>unistd.h<span style="color:#f92672">&gt;&lt;/</span>signal.h<span style="color:#f92672">&gt;&lt;/</span>sched.h<span style="color:#f92672">&gt;&lt;/</span>stdio.h<span style="color:#f92672">&gt;&lt;/</span>sys<span style="color:#f92672">&gt;&lt;/</span>sys<span style="color:#f92672">&gt;&lt;/</span>sys<span style="color:#f92672">&gt;</span>
</code></pre></div><p>sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">derios@ubuntu:~$ sudo ./mount 
Parent <span style="color:#f92672">[</span> 4517<span style="color:#f92672">]</span> - start a container!
Container <span style="color:#f92672">[</span>    1<span style="color:#f92672">]</span> - inside the container!
root@container:/# mount
proc on /proc type proc <span style="color:#f92672">(</span>rw,relatime<span style="color:#f92672">)</span>
sysfs on /sys type sysfs <span style="color:#f92672">(</span>rw,relatime<span style="color:#f92672">)</span>
none on /tmp type tmpfs <span style="color:#f92672">(</span>rw,relatime<span style="color:#f92672">)</span>
udev on /dev type devtmpfs <span style="color:#f92672">(</span>rw,relatime,size<span style="color:#f92672">=</span>493976k,nr_inodes<span style="color:#f92672">=</span>123494,mode<span style="color:#f92672">=</span>755<span style="color:#f92672">)</span>
devpts on /dev/pts type devpts <span style="color:#f92672">(</span>rw,relatime,mode<span style="color:#f92672">=</span>600,ptmxmode<span style="color:#f92672">=</span>000<span style="color:#f92672">)</span>
tmpfs on /run type tmpfs <span style="color:#f92672">(</span>rw,relatime<span style="color:#f92672">)</span>
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 <span style="color:#f92672">(</span>rw,relatime,errors<span style="color:#f92672">=</span>remount-ro,data<span style="color:#f92672">=</span>ordered<span style="color:#f92672">)</span>
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 <span style="color:#f92672">(</span>rw,relatime,errors<span style="color:#f92672">=</span>remount-ro,data<span style="color:#f92672">=</span>ordered<span style="color:#f92672">)</span>
/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 <span style="color:#f92672">(</span>rw,relatime,errors<span style="color:#f92672">=</span>remount-ro,data<span style="color:#f92672">=</span>ordered<span style="color:#f92672">)</span>

root@container:/# ls /bin /usr/bin
/bin:
bash   chmod  echo  hostname  less  more  mv   ping  rm   sleep  tail  test    top   truncate  uname
cat    chown  grep  ip        ln    mount  nc   ps    sed  tabs   tar   timeout  touch  tty     which
chgrp  cp     gzip  kill      ls    mountpoint  netstat  pwd   sh   tac    tee   toe    tr   umount

/usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
</code></pre></div>
        </div>

        
        
          <div class="btn-improve-page">
              <a href="https://github.com/pillumina/pillumina.Github.io/edit/master/content/posts/cloud-computing/docker-namespace.md">
                <i class="fas fa-code-branch"></i>
                Improve This Page
              </a>
          </div>
        

        
      <hr />
        <div class="row next-prev-navigator">


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
    
    
      
        
        
        <div class="col-md-12 next-article">
          <a href="/posts/design-pattern/go-visitor/" class="btn btn-outline-info">
            <span>Next <i class="fas fa-chevron-circle-right"></i></span>
            <br />
            <span>Go编程模式：Visitor（k8s）</span>
          </a>
        </div>
      
    
  

</div>

      <hr />
      
      
          <div id="disqus_thread"></div>
<script type="text/javascript">
  (function () {
    
    
    if (window.location.hostname == "localhost") return;

    var dsq = document.createElement("script");
    dsq.type = "text/javascript";
    dsq.async = true;
    var disqus_shortname = "pillumina";
    dsq.src = "//" + disqus_shortname + ".disqus.com/embed.js";
    (
      document.getElementsByTagName("head")[0] ||
      document.getElementsByTagName("body")[0]
    ).appendChild(dsq);
  })();
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>
<a href="https://disqus.com/" class="dsq-brlink"
  >comments powered by <span class="logo-disqus">Disqus</span></a
>

      
      </div>
    </div>
  </div>
  
</section>


      
      
  <section class="toc-section" id="toc-section">
    
    <div class="toc-holder">
      <h5 class="text-center pl-3">Table of Contents</h5>
      <hr>
      <div class="toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#什么是namespace">什么是Namespace</a></li>
    <li><a href="#uts-namespace">UTS Namespace</a></li>
    <li><a href="#ipc-namespace">IPC Namespace</a></li>
    <li><a href="#pid-namespace">PID Namespace</a></li>
    <li><a href="#mount-namespace">Mount Namespace</a></li>
    <li><a href="#docker的mount-namespace">Docker的Mount Namespace</a></li>
  </ul>
</nav>
      </div>
    </div>
    
  </section>

    </div>

    

  




  




  
  
    
  


<footer class="container-fluid text-center align-content-center footer pb-2">
  <div class="container pt-5">
    <div class="row text-left">
      <div class="col-md-4 col-sm-12">
        <h5>Navigation</h5>
        
        <ul>
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#about">About</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#skills">Skills</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#experiences">Experiences</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#recent-posts">Recent Posts</a>
              </li>
            
        </ul>
        

      </div>
      
      <div class="col-md-4 col-sm-12">
        <h5>Contact me:</h5>
        <ul>
          
          <li><span>Email: </span> <span>yxhuang@g.ucla.edu</span></li>
          
          <li><span>Phone: </span> <span>&#43;86-18657825298</span></li>
          
        </ul>
      </div>
      
      
    </div>
  </div>
  <hr />
  <div class="container">
    <div class="row text-left">
      <div class="col-md-4">
        <a id="theme" href="https://github.com/hossainemruz/toha" target="#">
          <img src="/assets/images/inverted-logo.png">
          Toha
        </a>
      </div>
      <div class="col-md-4 text-center">© 2020 Copyright.</div>
      <div class="col-md-4 text-right">
        <a id="hugo" href="https://gohugo.io/">Powered by
        <img
          src="/assets/images/hugo-logo-wide.svg"
          alt="Hugo Logo"
          height="18"
        />
        </a>
      </div>
    </div>
  </div>
</footer>

    <script src="/assets/js/jquery-3.4.1.min.js"></script>
<script src="/assets/js/popper.min.js"></script>
<script src="/assets/js/bootstrap.min.js"></script>

<script src="/assets/js/navbar.js"></script>
<script src="/assets/js/main.js"></script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
<script src="/assets/js/single.js"></script>
<script>
  hljs.initHighlightingOnLoad();
</script>


  </body>
</html>
