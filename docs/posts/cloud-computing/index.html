<!DOCTYPE html>
<html>
  <head>
    <title>Kubernetes &amp; Docker</title>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />


<link rel="stylesheet" href="/assets/css/bootstrap.min.css"/>
<link rel="stylesheet" href="/assets/css/layouts/main.css"/>
<link rel="stylesheet" href="/assets/css/style.css"/>
<link rel="stylesheet" href="/assets/css/navigators/navbar.css"/>


<link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" />


<link rel="icon" type="image/png" href="/assets/images/favicon.png" />


<link rel="stylesheet" href="/assets/css/style.css"/>

    
    <link rel="stylesheet" href="/assets/css/layouts/list.css">
    <link rel="stylesheet" href="/assets/css/navigators/sidebar.css">


    
    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-190574896-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
  </head>

  <body data-spy="scroll" data-target="#TableOfContents" data-offset="80">
    <div class="container-fluid bg-dimmed wrapper">
      
      
    


  


  


<nav class="navbar navbar-expand-xl top-navbar final-navbar shadow">
  <div class="container">
      <button class="navbar-toggler navbar-light" id="sidebar-toggler" type="button" onclick="toggleSidebar()">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/">
      <img src="/assets/images/main-logo.png">CctoctoFX</a>
    <button class="navbar-toggler navbar-light" id="toc-toggler" type="button" onclick="toggleTOC()">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse lang-selector" id="top-nav-items">
      <ul class="navbar-nav ml-auto">
      
      </ul>
    </div>
  </div>
  
  <img src="/assets/images/main-logo.png" class="d-none" id="main-logo">
  <img src="/assets/images/inverted-logo.png" class="d-none" id="inverted-logo">
</nav>



      
      
  
  

  <section class="sidebar-section" id="sidebar-section">
    <div class="sidebar-holder">
      <div class="sidebar" id="sidebar">
        <input type="text" value="" placeholder="Search" data-search="" id="search-box" />
        <div class="sidebar-tree">
          <ul class="tree" id="tree">
            <li id="list-heading"><a href="https://pillumina.github.io/posts" data-filter="all">Posts</a></li>
            <div class="subtree">
                
  
  
  
  
  
    
    <li><a class="" href="/posts/do-not-wall/">(转)别让自己墙了自己</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/how-to-learn/">(转)工程师应该如何高效学习</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/programmer-career/">(转)程序员如何把控自己的职业</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/black-magic/">Black Magic</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/iaas-paas-diff/">IaaS vs PaaS vs SaaS</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/links/">Tracking</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/golang/">Golang Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/golang/channels/">Channels Concurrency</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/fasthttp/">fasthttp对性能的优化研究</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/bdd-testing-framework/">Ginkgo 测试框架</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/lifecycle-of-http/">Go server中http请求的生命周期</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/go-testing/">Golang Testing Kits</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/memory-management/">Golang内存管理</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/schedualing/">Golang并发调度</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/golang-escape-analysis/">Golang逃逸分析</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/goroutine-pool/">Goroutine Pool</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/websocket/">Million WebSocket</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/go-profiling/">Profling Go Service</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/sync-pool/">Sync Pool源码分析</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/channel-graceful/">优雅关闭通道</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/golang/memory-leak/">可能的内存泄漏场景</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/java/">Java Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/java/java-fundamentals/">Java Fundamentals</a></li>
  


      </ul>
    </li>
  

  
  
  
  
    
    
  
  
    
    <li>
      <i class="fas fa-minus-circle"></i><a class="active" href="/posts/cloud-computing/">Kubernetes &amp; Docker</a>
      
      <ul class="active">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-basic/">Docker Cheat Sheet</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-aufs/">Docker Fundamentals (AUFS)</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-cgroup/">Docker Fundamentals (Cgroup)</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/docker-namespace/">Docker Fundamentals (Namespace)</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/k8s-config-update/">Kubernetes ConfigMap Hot Update</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/k8s-template/">Kubernetes Development</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/k8s-advance-schedule/">Kubernetes Handbook (Schedule)</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/k8s-basic/">Kubernetes Handbook (Start &amp; Pod)</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/cloud-computing/k8s-operator-dev/">Kubernetes Operator Development History</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/algo/">LC/CF刷题笔记</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/algo/string/">字符串专题</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/open_courses/">Open Courses</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/open_courses/cmu-15210/">CMU 15210</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/open_courses/cmu-15451/">CMU 15451</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/design-pattern/">Programming Pattern</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/design-pattern/">Design Pattern Overview</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/go-pipeline/">Go Pipeline Pattern</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/design-pattern/go-visitor/">Go Visitor Pattern (k8s)</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/python/">Python Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/python/python-functionality/">Python类自定义</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/rust/">Rust Odyssey</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/rust/basic/">Rust阅读索引集</a></li>
  


      </ul>
    </li>
  


            </div>
          </ul>
        </div>
      </div>
    </div>
  </section>


      
      
<section class="content-section" id="content-section">
  <div class="content container-fluid" id="content">
    <div class="container-fluid post-card-holder" id="post-card-holder">
      
      
        <div class="post-card">
  <a href="/posts/cloud-computing/k8s-operator-dev/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Kubernetes Operator Development History</h5>
        <p class="card-text post-summary">本文旨在记录对中间件、编排组件容器化部署后，实现kubernetes扩展组件Controller的过程。
 Third-Parties kubernetes-client: javascript
client-go
kube-rs
client-go源码分析 目录结构   kubernetes: contains the clientset to access Kubernetes API. discovery: discover APIs supported by a Kubernetes API server. dynamic: contains a dynamic client that can perform generic operations on arbitrary Kubernetes API objects. transport: set up auth and start a connection. tools/cache: useful for writing controllers. informers: informer group listers: lister group   代码实例 git clone https://github.com/huweihuang/client-go.git cd client-go #保证本地HOME目录有配置kubernetes集群的配置文件 go run client-go.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">April 29, 2021</span>
        <a
        href="/posts/cloud-computing/k8s-operator-dev/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/k8s-config-update/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Kubernetes ConfigMap 热更新</h5>
        <p class="card-text post-summary">注：如果对kubernetes的基本概念不太清楚，建议先过一下基本的资源类型再阅读此文
先随便给个例子:
apiVersion: v1 kind: ConfigMap metadata: name: test-config data: config.yml: |-start-message: &#39;Hello, World!&#39; log-level: INFO bootstrap.yml: listen-address: &#39;127.0.0.1:8080&#39; 我们定义了一个ConfigMap，data中定义了两个文件config.yml以及bootstrap.yml，当我们要引用当中的配置的时候，kubernetes提供了两种方案：
  使用configMapKeyRef引用configMap中某个文件的内容作为Pod中容器的环境变量。
  把所有configMap中的文件写到一个临时目录，将临时目录作为volume挂载到容器中，也就是configmap类型的volume。
假设现在我们有一个Deployment，它的pod模板里引用了configMap，现在我们的目标是：当configmap更新的时候，这个Deployment的业务逻辑也能随之更新。那么有哪些方案？
  最好的情况是，当configMap发生变更时，直接进行hot update，做到不影响pod的正常运行。
  如果无法hot update或者这样完成不了需求，就要出发对应的Deployment做一次滚动更新。
  场景一： 针对可以进行热更新的容器，进行配置热更新 如果configMap由volume挂载，比如下述的投射卷，它的内容是可以更新的：
apiVersion: v1 kind: Pod metadata: name: volume-test spec: containers: - name: container-test image: busybox volumeMounts: - name: all-in-one mountPath: &#34;/projected-volume&#34; readOnly: true volumes: - name: all-in-one projected: sources: - configMap: name: myconfigmap items: - key: config path: my-group/my-config 为了能够比较好得理解，先说明一下configMap的volume挂载机制：</p>
      </div>
      <div class="card-footer">
        <span class="float-left">April 24, 2021</span>
        <a
        href="/posts/cloud-computing/k8s-config-update/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/k8s-template/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Kubernetes Developement</h5>
        <p class="card-text post-summary">资源模板 statefulset举例 apiVersion: apps/v1beta1 kind: StatefulSet metadata: name: kubia spec: serviceName: kubia replicas: 2 template: metadata: labels: app: kubia spec: containers: - name: kubia image: derios/kubia ports: - name: http containerPort: 8080 volumeMounts: - name: data mountPath: /var/data volumeClaimTemplates: - metadata: name: data spec: resources: requests: storage: 1Mi accessModes: - ReadWriteOnce headless service举例 apiVersion: v1 kind: Service metadata: name: kubia spec: clusterIP: None selector: app: kubia ports: - name: http port: 80 storage class local PV kind: StorageClass apiVersion: storage.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">April 21, 2021</span>
        <a
        href="/posts/cloud-computing/k8s-template/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/k8s-advance-schedule/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Kubernetes Handbook (Schedule)</h5>
        <p class="card-text post-summary">内容涵盖  使用节点污点和pod容忍度阻止pod调度到特定节点 将节点亲缘性规则作为节点选择器的一种替代 使用节点亲缘性进行多个pod的共同调度 使用节点非亲缘性来分离多个pod  高级调度 在pod介绍的文章中可以看到，k8s可以通过在pod spec里面指定节点选择器，而这篇文章介绍的是后面其他逐渐加入的机制。
使用污点和容忍度阻止节点调度到特定节点 新特性： 节点污点、pod对于污点的容忍度
这些特性用于限制哪些pod可以被调度到某一个节点，也就是说只有当一个pod容忍某个节点的污点，这个pod才能被调度到该节点。
节点选择器和节点亲缘性规则，是明确在pod中添加的信息，来觉得一个pod可以或者不可以被调度到某个节点。而污点不一样，是在不修改已有pod信息的前提下，通过在节点上新增污点信息，来拒绝pod在这个节点的部署。
简单介绍污点和容忍度 我在自己的机器用minikube创建了k8s单点集群，用kubectl describe node minikube可以看到:
k describe node minikube Name: minikube Roles: master Labels: beta.kubernetes.io/arch=amd64 beta.kubernetes.io/os=linux deploy=test kubernetes.io/arch=amd64 kubernetes.io/hostname=minikube kubernetes.io/os=linux minikube.k8s.io/commit=b09ee50ec047410326a85435f4d99026f9c4f5c4 minikube.k8s.io/name=minikube minikube.k8s.io/updated_at=2021_03_30T20_15_58_0700 minikube.k8s.io/version=v1.14.0 node-role.kubernetes.io/master= Annotations: kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock node.alpha.kubernetes.io/ttl: 0 volumes.kubernetes.io/controller-managed-attach-detach: true CreationTimestamp: Tue, 30 Mar 2021 20:15:55 +0800 Taints: &lt;none&gt; # -----&gt; 主节点暂时没有污点 Unschedulable: false Lease: HolderIdentity: minikube AcquireTime: &lt;unset&gt; RenewTime: Fri, 09 Apr 2021 14:48:12 +0800 可以看到Taints属性，表示目前这个主节点没有污点。不过这里可以举个例子：</p>
      </div>
      <div class="card-footer">
        <span class="float-left">April 9, 2021</span>
        <a
        href="/posts/cloud-computing/k8s-advance-schedule/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/docker-aufs/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Docker Fundamentals: AUFS</h5>
        <p class="card-text post-summary">AUFS是一种Union File System，所谓的UnionFS实际上就是把不同物理位置的目录合并mount到同一个目录当中。一种典型的UnionFS的应用，就是把一张CD/DVD和一个硬盘目录联合mount在一起，然后你就可以对这个只读的CD/DVD上的文件进行修改。
AUFS又叫做Another UnionFS，后面改成Alternative UnionFS，然后又变成Advance UnionFS&hellip;..当然名字的改变叫啥不重要，本质还是没变的。2006年Junjiro Okajima开发了AUFS，完全重写了早期的UnionFS 1.X，主要目的是为了可靠性和性能，再引入一些新的功能，例如可写分支的负载均衡。不过很有意思的是，AUFS的性能比UnionFS 1.X好很多，后面UnionFS 2.x就抄AUFS的功能，而AUFS本身却没有合入到Linux主线，因为代码量太大质量也不好。虽然后面Junjiro不断提升代码质量，不断提交但是还是被Linus拒绝了。所以哪怕是今天AUFS也没进到Linux里，虽然质量已经可以了。
不过一些发行版比如：Ubuntu 10.04，Debian6.0都支持AUFS，所以也还好。我在Ubuntu 14.04演示一下例子。
首先，我们建立两个水果和蔬菜的目录，在这个目录上放一些文件，水果里有苹果和番茄，蔬菜有胡萝卜和番茄:
$ tree . ├── fruits │ ├── apple │ └── tomato └── vegetables ├── carrots └── tomato 然后输入:
# 创建一个mount目录 $ mkdir mnt # 把水果目录和蔬菜目录union mount到 ./mnt目录中 $ sudo mount -t aufs -o dirs=./fruits:./vegetables none ./mnt # 查看./mnt目录 $ tree ./mnt ./mnt ├── apple ├── carrots └── tomato 可以看到mnt目录下有三个文件，水果和蔬菜的目录被合并起来了。如果我们修改一下文件内容:
$ echo mnt &gt; ./mnt/apple $ cat .</p>
      </div>
      <div class="card-footer">
        <span class="float-left">April 6, 2021</span>
        <a
        href="/posts/cloud-computing/docker-aufs/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/docker-cgroup/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Docker Fundamentals: Cgroup</h5>
        <p class="card-text post-summary">Linux Namespace的技术解决了环境隔离的问题，不过这是虚拟化最基本的一步，我们另外需要解决对计算机资源使用上的隔离。说人话，就是虽然Namespace把我关到一个特定的环境，但是里面进程使用的CPU、内存、磁盘等计算资源实际上没有被限制。这个问题的解决，就要用到CGroup技术。
Linux CGroup全称是Linux Control Group，也是其内核的一个功能，用于限制、控制和分离一个进程group的资源。最早这个项目是2006年由谷歌的工程师发起的，最开始名称是process containers（工程容器），后面觉得内核中容器这个名词被用烂了，就改名为cgroup。
CGroup可以让你对系统中运行的进程的用户组分配资源-CPU时间、系统内存、网络带宽亦或者是这些的组合。同时，也可以监控你配置的cgroup，拒绝cgroup访问某些资源。主要提供的功能如下：
  Resource Limitation： 限制资源使用
  Prioritization: 优先级控制，例如CPU使用和磁盘IO吞吐
  Accounting：审计统计，主要用于计费
  Control：挂起进程，恢复执行进程
在真正的实践当中，system admin一般会利用CGroup做以下的事：
  对进程集合进行隔离，限制他们所消费的资源，例如绑定CPU core
  为这组进程分配足够使用的内存
  为这组进程分配响应的网络带宽和磁盘存储限制
  限制访问某些设备（白名单）
Linux实际上把CGroup实现成了一个文件系统，你可以mount。在linux环境输入下面的可以看到cgroup已经为你mount好：
  derios@ubuntu:~$ mount -t cgroup cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset) cgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu) cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct) cgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory) cgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio) cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio) cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb) 可以看到，在/sys/fs下有cgroup目录，这个目录下面有各种子目录：cpu，cpuset，memory&hellip;。这些都是cgroup的子系统，分别用来干不同的事。</p>
      </div>
      <div class="card-footer">
        <span class="float-left">April 5, 2021</span>
        <a
        href="/posts/cloud-computing/docker-cgroup/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/docker-namespace/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Docker Fundamentals: Namespace</h5>
        <p class="card-text post-summary">容器技术出现已经很久，只不过Docker容器平台的出现它变火了。Docker是第一个让容器能在不同机器之间移植的系统，它简化了打包应用的流程，也简化了打包应用的库和各种依赖。思考下整个OS的file system能直接被打包成一个简单的可移植的包，一开始的时候概念上还是很有趣的。
有时候我认为自己的阅读比较碎片化(short-term memory越来越少)，所以我想把之前学习容器知识的一些基础技术再整理出来，也算是给自己学习的反馈。这个基础系列从Linux Namespace开始，后续会陆续介绍比如cgroup、aufs、devicemapper等技术。
参考 Namespace in operation
Linux namespace man page
Introduction to linux namespace
什么是Namespace 简单来说，linux namespace是Linux提供的一种内核级别环境隔离的方法。在早期的Unix中，提供了一种叫做chroot的系统调用：通过修改root目录把用户关到一个特定的目录下面。这种就是简单的隔离方式，也就是chroot内部的file system无法访问外部的内容。Linux Namespace在此基础之上，提供了对UTS、IPC、mount、network、PID、User等隔离机制。
这里可以简单举例，比如Linux的超级父进程的PID为1，如果我们可以把用户的进程空间关到某个进程分支之下，并且像chroot那样能够让下面的进程看到那个超级父进程的PID为1，而不同PID Namespace中的进程无法看到彼此，这样就能达到进程隔离。
Linux Namespace有以下的种类，供给后续参考（刚看有个印象就行）：
   分类 系统调用参数 相关内核版本     Mount namespaces CLONE_NEWNS Linux 2.4.19   UTS namespaces CLONE_NEWUTS Linux 2.6.19   IPC namespaces CLONE_NEWIPC Linux 2.6.19   PID namespaces CLONE_NEWPID Linux 2.6.24   Network namespaces CLONE_NEWNET 始于Linux 2.6.24 完成于 Linux 2.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">April 1, 2021</span>
        <a
        href="/posts/cloud-computing/docker-namespace/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/k8s-basic/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Kubernetes Handbook (Start &amp; Pod)</h5>
        <p class="card-text post-summary">使用minikube构建本地单节点k8s集群  minikube ssh kubectl cluster-info kubectl get nodes #查看节点信息 kubectl describe node minikube #详细信息  多节点k8s集群，使用Google K8s Engine 构建方式看GKE官网即可
k8s初步使用 kubectl run kubia &ndash;image=derios/kubia &ndash;port=8080 &ndash;generator=run/v1
 --image=derios/kubia代表要运行的容器镜像 这里的--generator会被废弃，其含义指代的是创建一个ReplicationController而不是Deployment。 kubectl apply -f 更常用 kubectl get pods kubectl get pods -o wide 显示pod ip和pod的节点 如果使用GWE，可以访问集群的dashborad: kubectl clusert-info获取地址 gcloud container clusters describe kubia | grep -E &ldquo;(username|password):&ldquo;获取用户名和密码 如果仅仅使用minikube，则如下不需要任何凭证即可访问:  minikube dashboard Namespace相关操作 kubectl config set-context --current --namespace=my-namespace 创建服务对象，访问Web应用 如果使用minikube或者kubeadm等自定义k8s，loadbalancer是没有集成的，需要AWS或者Google Cloud。最好使用NodePort或者Ingress Controller。如果真要用minikube, 可以使用minikube tunnel解决, 或者minikube service kubia-http</p>
      </div>
      <div class="card-footer">
        <span class="float-left">March 31, 2021</span>
        <a
        href="/posts/cloud-computing/k8s-basic/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/cloud-computing/docker-basic/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/images/posts/k8s-docker.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Docker Cheat Sheet</h5>
        <p class="card-text post-summary">Books Docker in Action (English ver.)
Docker入门到实践(中文)
速查 Docker Cheat Sheet
全量CLI 容器管理CLI 查看容器CLI 容器交互CLI 镜像管理CLI 镜像传输CLI DOCKERFILE主要命令 Dockerfile 基底 FROMruby:2.2.2变量 ENV APP_HOME/myappRUN mkdir $APP_HOME初始化 RUN bundle installWORKDIR/myappVOLUME [&#34;/data&#34;]# Specification for mount pointADD file.xyz /file.xyzCOPY --chown=user:group host_file.xyz /path/container_file.xyzOnbuild ONBUILD RUN bundle install# when used with another file命令 EXPOSE5900CMD [&#34;bundle&#34;, &#34;exec&#34;, &#34;rails&#34;, &#34;server&#34;]Entrypoint ENTRYPOINT exec top -bMetadata LABEL version=&#34;1.0&#34;LABEL &#34;com.example.vendor&#34;=&#34;ACME Incorporated&#34;LABEL com.example.label-with-value=&#34;foo&#34;LABEL description=&#34;This text illustrates \ that label-values can span multiple lines.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">March 30, 2021</span>
        <a
        href="/posts/cloud-computing/docker-basic/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
    </div>
    <div class="paginator">
      


    </div>
  </div>
</section>


      
       
    </div>

    

  




  




  
  
    
  


<footer class="container-fluid text-center align-content-center footer pb-2">
  <div class="container pt-5">
    <div class="row text-left">
      <div class="col-md-4 col-sm-12">
        <h5>Navigation</h5>
        
        <ul>
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#about">About</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#skills">Skills</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#experiences">Experiences</a>
              </li>
            
            
              
              
                
              
              <li class="nav-item">
                <a class="smooth-scroll" href="#recent-posts">Recent Posts</a>
              </li>
            
        </ul>
        

      </div>
      
      <div class="col-md-4 col-sm-12">
        <h5>Contact me:</h5>
        <ul>
          
          <li><span>Email: </span> <span>yxhuang@g.ucla.edu</span></li>
          
          <li><span>Phone: </span> <span>&#43;86-18657825298</span></li>
          
        </ul>
      </div>
      
      
    </div>
  </div>
  <hr />
  <div class="container">
    <div class="row text-left">
      <div class="col-md-4">
        <a id="theme" href="https://github.com/hossainemruz/toha" target="#">
          <img src="/assets/images/inverted-logo.png">
          Toha
        </a>
      </div>
      <div class="col-md-4 text-center">© 2020 Copyright.</div>
      <div class="col-md-4 text-right">
        <a id="hugo" href="https://gohugo.io/">Powered by
        <img
          src="/assets/images/hugo-logo-wide.svg"
          alt="Hugo Logo"
          height="18"
        />
        </a>
      </div>
    </div>
  </div>
</footer>

    <script src="/assets/js/jquery-3.4.1.min.js"></script>
<script src="/assets/js/popper.min.js"></script>
<script src="/assets/js/bootstrap.min.js"></script>

<script src="/assets/js/navbar.js"></script>
<script src="/assets/js/main.js"></script>


    
    
    <script src="/assets/js/list.js"></script>

  </body>
</html>
